{"meta":{"title":"Vinson-sheep博客","subtitle":"纯粹想赚点小钱钱","description":"分享技术和生活的博客","author":"Vinson-sheep","url":""},"pages":[{"title":"About","date":"2017-09-22T16:30:56.768Z","updated":"2017-09-22T16:30:56.768Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我@card{ yangyongsheng 别名vinson、Vinson-sheep、文森羊。 暨南大学在校学生。 记得一开始，自己什么也不懂，对于编辑器是何物也是茫然。渐渐接触了html和css后，开始对网站的编码感兴趣，于是选择了前端方向发展。不过我究竟还是个初学者，为了解更多知识，我还上网找了不少资料、看了不少书籍。我发现，像CSDN和知乎这些社交类平台，大家都很乐意分享自己的知识。不知是否是有利益驱使，他们这种乐于分享的精神是我很赞赏的。 偶然看到有些技术大咖会有自己的博客，他们会利用自己这个平台构建一个知识分享的社区，对我来说，这是梦幻般的事情。同样通过代码世界的子民分享的知识，我学习了javascript而又跑去后端构建数据库和编写脚本。途中种种bug还有前行者的细心解答，让我收益匪浅。代码世界的前行，究竟还是少不了其他子民的共同努力。 我想做个浪漫的人，这个博客为此诞生了。我希望通过这个网站发布一些技术文章、图片甚至是自己写的小说，为你的生活添上色彩。 如果你喜欢，欢迎点赞和评论。 } 关于本网站@card{ www.vinsongeek.com是用来分享信息和做学习记录的个人博客。 博客文章并非100%，内容多少会参考其他博主的资料，所以我尽可能地在每篇文章底部注明来源，以示尊重。 如果本站文章侵犯了其他笔者的原创作品，请联系删除。 本站文章不作商业用途，如需转载请联系站长。 } 联系方式@card{ QQ: 775014077 邮箱: 775014077@qq.com }"},{"title":"categories","date":"2017-09-21T06:08:02.000Z","updated":"2017-09-22T14:41:25.245Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"画廊","date":"2017-09-30T17:36:36.064Z","updated":"2017-09-30T17:36:36.064Z","comments":false,"path":"gallery/index.html","permalink":"/gallery/index.html","excerpt":"","text":"Miku 这是我接触SAI上色的第一幅作品。个人对于上色还是挺自信的，嘿嘿，先舔屏 涂鸦作品 以学院团学会代表身份参加的涂鸦大赛，拿个三等奖 暨妹妹 暨妹妹是我喜欢为数不多的几个角色之一，特意画了一下她生气的样子，看来我在某方面没救了。 字体设计 大二时候为部门设计的字体，用铅笔描格子，最后用PS得到完整的png图片（这里就不放了），看看原稿就好。"},{"title":"tags","date":"2017-09-21T06:07:44.000Z","updated":"2017-09-21T06:08:43.039Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"windows中python读取路径的使用","slug":"windows中python读取路径的使用","date":"2017-10-26T15:40:14.000Z","updated":"2017-10-26T15:47:20.342Z","comments":true,"path":"2017/10/26/windows中python读取路径的使用/","link":"","permalink":"/2017/10/26/windows中python读取路径的使用/","excerpt":"由于我是主攻前端的，一般的页面开发会在windons系统上。然而有不得不写后端的时候，比如前端需要api进行调试。我实际学习的时候，我发现python读取文件在Linux和windows的行为不一样。","text":"由于我是主攻前端的，一般的页面开发会在windons系统上。然而有不得不写后端的时候，比如前端需要api进行调试。我实际学习的时候，我发现python读取文件在Linux和windows的行为不一样。 首先，”/“左倾斜是正斜杠,”\\”右倾斜是反斜杠,可以记为：除号是正斜杠一般来说对于目录分隔符，Unix和Web用正斜杠/，Windows用反斜杠，但是现在Windows 目录中的斜杠们python读文件需要输入的目录参数，列出以下例子：1234path = r\"C:\\Windows\\temp\\readme.txt\"path1 = r\"c:\\windows\\temp\\readme.txt\"path2 = \"c:\\\\windows\\\\temp\\\\readme.txt\"path3 = \"c:/windows/temp/readme.txt\" 打开文件函数open()中的参数可以是path也可以是path1、path2、path3。 path：”\\”为字符串中的特殊字符，加上r后变为原始字符串，则不会对字符串中的”\\t”、”\\r”进行字符串转义 path1：大小写不影响windows定位到文件 path3：用正斜杠做目录分隔符也可以转到对应目录，并且在python中path3的方式也省去了反斜杠\\转义的烦恼 正则表达式中的斜杠们正则表达式匹配反斜杠”\\”，为什么是”\\\\“或是 r”\\“呢？ 因为在正则表达式中\\为特殊符号，为了取消它在正则表达式中的特殊意义需要加一个\\就变成了\\，但是问题又来了，\\也是字符串中的特殊字符，所以又要分别对两个\\取消其特殊意义，即为\\\\。Python中有一个原始字符串操作符，用于那些字符串中出现特殊字符，在原始字符串中，没有转义字符和不能打印的字符。这样就可以取消了\\在字符串中的转义功能，即r”\\“。 传送门： python 对反斜杠的处理问题","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"python3","slug":"python3","permalink":"/tags/python3/"}]},{"title":"flask中file.save小坑","slug":"flask中file-save小坑","date":"2017-10-26T15:20:04.000Z","updated":"2017-10-26T15:30:37.211Z","comments":true,"path":"2017/10/26/flask中file-save小坑/","link":"","permalink":"/2017/10/26/flask中file-save小坑/","excerpt":"最近挖了文件上传的坑，刚开始就遇到了小坑，花了我很多时间去专研这个问题。","text":"最近挖了文件上传的坑，刚开始就遇到了小坑，花了我很多时间去专研这个问题。 flask文档上面有关上传文件的实例，我copy下来，放在本地运行。1234567891011121314151617181920212223242526272829303132import osfrom flask import Flask, request, redirect, url_forfrom werkzeug import secure_filenameUPLOAD_FOLDER = '/path/to/the/uploads'ALLOWED_EXTENSIONS = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'])app = Flask(__name__)app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDERdef allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS@app.route('/', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': file = request.files['file'] if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return redirect(url_for('uploaded_file', filename=filename)) return ''' &lt;!doctype html&gt; &lt;title&gt;Upload new File&lt;/title&gt; &lt;h1&gt;Upload new File&lt;/h1&gt; &lt;form action=\"\" method=post enctype=multipart/form-data&gt; &lt;p&gt;&lt;input type=file name=file&gt; &lt;input type=submit value=Upload&gt; &lt;/form&gt; ''' 结果出现no such file or directory之类的文字，python是很明确地说明是save.file函数保存文件路径出了问题。 实际上这个问题网上很多帖子，然而答案很模糊。实际问题在于就是file.save只接受绝对路径。这个不管是Linux还是windows都是一样的。 传送门：记录一个Flask文件上传的小坑","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"/tags/flask/"}]},{"title":"四种常见的POST提交数据方式","slug":"四种常见的POST提交数据方式","date":"2017-10-26T11:13:59.000Z","updated":"2017-10-26T15:21:17.952Z","comments":true,"path":"2017/10/26/四种常见的POST提交数据方式/","link":"","permalink":"/2017/10/26/四种常见的POST提交数据方式/","excerpt":"最近看了一篇文章，相当有启发性，它解决了我对http请求中数据传输格式的困惑。在未来的表单页面制作，通过设置表单enctype属性能够实现更多的功能。上面也提及到json的前端设置，我觉得很有必要做做记录。","text":"最近看了一篇文章，相当有启发性，它解决了我对http请求中数据传输格式的困惑。在未来的表单页面制作，通过设置表单enctype属性能够实现更多的功能。上面也提及到json的前端设置，我觉得很有必要做做记录。 title说有四种常见的POST提交数据方式，其实有五种，最后一种不常见而已 这里说到的POST方式，都可以作为数据的描述，使用ajax提交给服务器。 application/x-www-form-urlencoded这应该是最常见的POST提交数据方式了。 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 multipart/form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例：12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"text\"title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 application/jsonapplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。1234POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8&#123;\"title\":\"test\",\"sub\":[1,2,3]&#125; text/xml123456789101112POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;!--?xml version=\"1.0\"?--&gt;&lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt;&lt;/methodcall&gt; 我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。 text/plain在菜鸟教程的描述是： 将空格转换为 “+” 符号，但不编码特殊字符。 其实实际开发中用得非常少，而且资料也不多，在这里不介绍了。 传送门： application/json 四种常见的 POST 提交数据方式","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"表单","slug":"表单","permalink":"/tags/表单/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"python3 datetime与字符串的转换","slug":"python3-datetime与字符串的转换","date":"2017-10-25T14:58:06.000Z","updated":"2017-10-25T15:11:08.870Z","comments":true,"path":"2017/10/25/python3-datetime与字符串的转换/","link":"","permalink":"/2017/10/25/python3-datetime与字符串的转换/","excerpt":"写后台脚本的时候遇到了，mysql输出给pymysql的数据类型为datetime，而json不能直接将datetime对象转化为string，所以需要通过显式转换将datetime转换为string。","text":"写后台脚本的时候遇到了，mysql输出给pymysql的数据类型为datetime，而json不能直接将datetime对象转化为string，所以需要通过显式转换将datetime转换为string。 datetime =&gt; string12345import datetimedate=datetime.datetime.now()str=date.strftime(\"%Y-%m-%d %H:%M:%S\")str # =&gt; '2017-10-25 23:04:32' string =&gt; datetime1234import timestr = '2012-08-29 19:45:57'date = time.strptime(str, \"%Y-%m-%d %H:%M:%S\") 在这里有一点甚是奇怪在本地win10上调试，mysql输出的是datetime对象，但是在Ubuntu14上，mysql的datetime输出的东西可以被json化。关于这个差异，博主在写这篇文章的时候，也没能解决。如果有人看到这篇文字，知道原因，可以发邮件给我。 email: 775014077@qq.com 传送门： python time 和datetime类型转换，字符串型变量转成日期型变量 python datetime与字符串互转","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"python3","slug":"python3","permalink":"/tags/python3/"}]},{"title":"Ubuntu14.05彻底卸载mysql","slug":"Ubuntu14-05彻底卸载mysql","date":"2017-10-25T14:31:20.000Z","updated":"2017-10-25T14:45:56.780Z","comments":true,"path":"2017/10/25/Ubuntu14-05彻底卸载mysql/","link":"","permalink":"/2017/10/25/Ubuntu14-05彻底卸载mysql/","excerpt":"我弄mysql的时候把mysql服务停了，发现有些依赖mysql的功能在Mysql服务重启之后就出了点问题。折腾了许久，愤怒之下决定删mysql再重装，可是我发现mysql卸载一点都不容易。特地写下blog,方便以后使用。","text":"我弄mysql的时候把mysql服务停了，发现有些依赖mysql的功能在Mysql服务重启之后就出了点问题。折腾了许久，愤怒之下决定删mysql再重装，可是我发现mysql卸载一点都不容易。特地写下blog,方便以后使用。 参考了许多文章，只有这一篇可行。（略有改动） mysql5.7 Ubuntu14 停止mysql服务1sudo /etc/init.d/mysql stop 删除mysql的数据文件1sudo rm /var/lib/mysql/ -R 删除mysql的配置文件1sudo rm /etc/mysql/ -R 自动卸载mysql（包括server和client）12sudo apt-get autoremove mysql* --purgesudo apt-get remove apparmor 检查是否卸载干净1dpkg -l | grep mysql # 若没有返回，说明已完成卸载 接下来安装就是件简单的事情啦1sudo apt-get install mysql-server mysql-client 这样默认安装的是mysql 5.5的版本，后续尝试安装mysql5.7，稍后补充5.7的安装。 传送门： mysql-ubuntu14.04彻底卸载mysql","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu14mysq5.7不支持中文问题","slug":"Ubuntu14mysq5-7不支持中文问题","date":"2017-10-25T12:48:51.000Z","updated":"2017-10-25T13:27:58.982Z","comments":true,"path":"2017/10/25/Ubuntu14mysq5-7不支持中文问题/","link":"","permalink":"/2017/10/25/Ubuntu14mysq5-7不支持中文问题/","excerpt":"不得不说，用mysql坑很多，首先就是编码问题。按照网上搜到的答案来处理，很多次我都不能restart mysql了。最后发现是版本问题，在这里我得做文章记录一下。","text":"不得不说，用mysql坑很多，首先就是编码问题。按照网上搜到的答案来处理，很多次我都不能restart mysql了。最后发现是版本问题，在这里我得做文章记录一下。 mysql本身是不支持中文的，这个我在win10搭建的服务器也碰到过。想要mysql支持中文，就需要更改它的设置。 请看完这篇文章再动手 mysql5.7 Ubuntu14.05 首先停下mysql服务：1sudo /etc/init.d/mysql stop 然后用gedit打开mysql配置文件1sudo gedit /etc/mysql/my.cnf [client]下添加：1default-character-set=utf8 [mysqld]下添加：1default-character-set=utf8 保存退出 重启mysql服务1sudo service mysql restart 然而…1Job failed to start 问题在哪呢？ 可能是版本的问题，查5.5以后的版本对字符编码方式修改的办法，发现[mysqld]修改方法变了： [mysqld]下添加的应该为：123character-set-server=utf8collation-server=utf8_general_ci 保存退出1sudo service mysql restart 成功 查看字符集1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 传送们： 参考资料1——Ubuntu15下mysql5.6.25解决不支持中文的办法 参考资料2——修改mysql字符编码出现Job failed to start解决办法 参考资料3——Ubuntu MySQL插入中文出错","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"}]},{"title":"CSS3中user-select的使用","slug":"CSS3中user-select的使用","date":"2017-10-22T07:25:33.000Z","updated":"2017-10-22T07:39:24.655Z","comments":true,"path":"2017/10/22/CSS3中user-select的使用/","link":"","permalink":"/2017/10/22/CSS3中user-select的使用/","excerpt":"","text":"语法：user-select：none | text | all | element12345默认值：text适用于：除替换元素外的所有元素继承性：无动画性：否计算值：指定值 取值：12345678none：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束 说明：设置或检索是否允许用户选中文本。 IE6-9不支持该属性，但支持使用标签属性 onselectstart=”return false;” 来达到 user-select:none 的效果；Safari和Chrome也支持该标签属性； 直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=”on” 来达到 user-select:none 的效果；unselectable 的另一个值是 off； 除Chrome和Safari外，在其它浏览器中，如果将文本设置为 -ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 -ms-user-select:none; 的区域文本； 对应的脚本特性为userSelect。 实例：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;user-select_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;meta name=\"author\" content=\"Joy Du(飘零雾雨), dooyoe@gmail.com, www.doyoe.com\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;&lt;style&gt;.test&#123;padding:10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;background:#eee;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"test\" onselectstart=\"return false;\" unselectable=\"on\"&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 传说门user-select","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"jquery插件blindify详解","slug":"jquery插件blindify详解","date":"2017-10-22T05:58:19.000Z","updated":"2017-10-22T06:18:28.749Z","comments":true,"path":"2017/10/22/jquery插件blindify详解/","link":"","permalink":"/2017/10/22/jquery插件blindify详解/","excerpt":"百叶窗插件，因为使用的是jquery，所以兼容大部分浏览器，ie兼容9+。","text":"百叶窗插件，因为使用的是jquery，所以兼容大部分浏览器，ie兼容9+。 简介 Blindify 是一个基于 jQuery 的百叶窗幻灯片插件，它能够非常方便的制作一个漂亮的百叶窗效果，你还可以设置百叶窗的片数、间隔、宽度、高度以及各种动画效果的时间和百叶窗的方向——水平或垂直。 兼容jQuery 兼容兼容 1.4+。 浏览器兼容 使用方法1、 引入文件123&lt;link rel=\"stylesheet\" href=\"css/blindify.min.css\"&gt;&lt;script src=\"js/jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.blindify.min.js\"&gt;&lt;/script&gt; 2、 HTML12345678&lt;div id=\"blindify\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/photo_1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 或者带有链接：12345678&lt;div id=\"blindify\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_1.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_2.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_3.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_4.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3、JavaScript123$(function()&#123; $('#blindify').blindify();&#125;); 配置 属性/方法 类型 默认值 说明 numberOfBlinds 整数 20 百叶窗叶片个数 slideVisibleTime 整数 2000 每个幻灯片的停留时间，不包括动画时间，以毫秒为单位 color 字符串 #000000 幻灯片背景颜色（十六进制颜色） margin 整数 2 百叶窗之间的距离，以像素（px）为单位。注意：其实是每个百叶窗的边框，所以如果想设置距离为10px，只需设置一半5px width 整数 960 容器的宽度，应与图片的宽度一样，以像素为单位 height 整数 600 容器的高度，应与图片的宽度一样，以像素为单位 gap 整数 100 百叶窗与容器边缘的距离范围，以像素为单位 animationSpeed 整数 100 幻灯片动画过度时间 delayBetweenSlides 整数 500 每个幻灯片切换之间的间隔，以毫秒为单位 hasLinks 布尔值 false 是否有链接 orientation 字符串 vertical 百叶窗的方向，可选水平（horizontal）或垂直（vertical），默认为垂直 startClosed 布尔值 false 百叶窗开始时是否关闭 firstOpenDelay 整数 500 startClosed 为 true 时，百叶窗延迟打开时间，单位为毫秒","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"},{"name":"jquery插件","slug":"jquery插件","permalink":"/tags/jquery插件/"}]},{"title":"css更改表单控件光标颜色","slug":"css更改表单控件光标颜色","date":"2017-10-21T16:35:50.000Z","updated":"2017-10-21T16:42:53.407Z","comments":true,"path":"2017/10/22/css更改表单控件光标颜色/","link":"","permalink":"/2017/10/22/css更改表单控件光标颜色/","excerpt":"看到一个比较新颖的文章，记录一下。","text":"看到一个比较新颖的文章，记录一下。 一般表单控件光标的颜色跟color属性是一致的。 如果想仅仅改变光标颜色，需要特殊的CSS设置。 一直以来要实现这样的效果都是依靠模拟来实现。主要借助于CSS的`-webkit-text-fill-color让文本变成镂空的，即把其设置为transparent，记住了，不是直接将color的值设置为transparent。除此之外，还需要借助text-shadow的威力。直接上代码吧：12345.form-control &#123; color: red !important; text-shadow: 0px 0px 0px #495057; -webkit-text-fill-color: transparent;&#125; 到今天为止，我们不需要这么蛋疼了。CSS提供了一个属性caret-color，可以直接让我们控制input和textarea控件的光标颜色，甚至是可编辑的HTML元素，像这样的&lt;div contenteditable&gt;。如此一来，只需要在样式中添加：123456input,textarea,[contenteditable] &#123; color: #495057; /* 文本颜色 */ caret-color: red; /* 光标颜色 */&#125; caret-color较三行代码兼容性差些。 传送门：如何改变表单控件光标颜色","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"CSS3弹性盒子Flex Box","slug":"CSS3弹性盒子Flex-Box","date":"2017-10-20T16:52:35.000Z","updated":"2017-10-20T16:54:17.561Z","comments":true,"path":"2017/10/21/CSS3弹性盒子Flex-Box/","link":"","permalink":"/2017/10/21/CSS3弹性盒子Flex-Box/","excerpt":"CSS3中flexBox其实也是一个大的领域，下面我为flexBox做简单的归纳。","text":"CSS3中flexBox其实也是一个大的领域，下面我为flexBox做简单的归纳。 CSS3 弹性盒子(Flex Box)","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"CSS3收集","slug":"CSS3收集","date":"2017-10-20T16:41:41.000Z","updated":"2017-10-22T05:28:00.636Z","comments":true,"path":"2017/10/21/CSS3收集/","link":"","permalink":"/2017/10/21/CSS3收集/","excerpt":"收集了一些比较好、有价值的CSS组件源码，供学习使用。","text":"收集了一些比较好、有价值的CSS组件源码，供学习使用。 按钮 鼠标移动到按钮上后添加箭头标记 波纹效果 按压效果 图片 响应式卡片 图片模态框 幻灯片 制作简单的响应式幻灯片 Blindify – jQuery百叶窗幻灯片插件","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"讨论CSS伪元素的父元素","slug":"讨论CSS伪元素的父元素","date":"2017-10-20T15:33:52.000Z","updated":"2017-10-20T15:56:34.820Z","comments":true,"path":"2017/10/20/讨论CSS伪元素的父元素/","link":"","permalink":"/2017/10/20/讨论CSS伪元素的父元素/","excerpt":"为什么要讨论css中伪元素的父元素呢？因为很多时候需要用到position属性，而position属性效果跟父元素直接挂钩。这篇文章就是讨论CSS中伪元素的父元素到底是谁？","text":"为什么要讨论css中伪元素的父元素呢？因为很多时候需要用到position属性，而position属性效果跟父元素直接挂钩。这篇文章就是讨论CSS中伪元素的父元素到底是谁？ 什么是伪元素？参考菜鸟教程列出所有的伪元素 :link :visited :active :focus :first-letter :first-line :first-child :before :after lang(language) 测试1以:first-letter写一段html和css：1234567891011// html&lt;p id=\"test\"&gt;假猪套天下第一&lt;/p&gt;// css&lt;style&gt;#test &#123; font-size: 15px; &#125;#test:first-letter &#123; font-size: 20px;&#125;&lt;/style&gt; 在浏览器中测试以上代码： 测试结果 很明显，#test:first-letter覆盖了#test的CSS样式。 所以#test:first-letter是#test的子元素。 神马？证明还不够充分？再来！ 测试2拿菜鸟教程的一个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;.button &#123; display: inline-block; border-radius: 4px; background-color: #f4511e; border: none; color: #FFFFFF; text-align: center; font-size: 28px; padding: 20px; width: 200px; transition: all 0.5s; cursor: pointer; margin: 5px;&#125;.button span &#123; cursor: pointer; display: inline-block; position: relative; transition: 0.5s;&#125;.button span:after &#123; content: '»'; position: absolute; opacity: 0; top: 0; right: -20px; transition: 0.5s;&#125;.button:hover span &#123; padding-right: 25px;&#125;.button:hover span:after &#123; opacity: 1; right: 0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;按钮动画&lt;/h2&gt;&lt;button class=\"button\" style=\"vertical-align:middle\"&gt;&lt;span&gt;Hover&lt;/span&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 仔细观察123.button span:after &#123; position: absolute;&#125; 和123.button span &#123; position: relative;&#125; 就relative和absolute的前后关系，可以直接表明span是span:after的父元素。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"}]},{"title":"CSS3新元素使用列表","slug":"CSS3新元素使用列表","date":"2017-10-19T16:01:12.000Z","updated":"2017-10-20T16:52:11.300Z","comments":true,"path":"2017/10/20/CSS3新元素使用列表/","link":"","permalink":"/2017/10/20/CSS3新元素使用列表/","excerpt":"最近想做一些UI组件，稍微复习一下CSS3的内容。","text":"最近想做一些UI组件，稍微复习一下CSS3的内容。 边框border-radiusbox-shadow1box-shadow: 10px 10px 5px #888888; border-image123-webkit-border-image: url(border.png) 30 round; /* Safari 3.1-5 */-o-border-image: url(border.png) 30 round; /* Opera 11-12.1 */border-image: url(border.png) 30 round; 圆角border-radius 背景background-imagebackground-sizebackground-origin12background-size:100% 100%;background-origin:content-box; background-clip1background-clip: content-box; 渐变（Gradients）传送门 文本效果text-shadow1text-shadow: 5px 5px 5px #FF0000; box-shadow1box-shadow: 10px 10px grey; text-overflow1text-overflow:ellipsis; word-wrap1word-wrap:break-word; word-break12word-break:keep-all;word-break:break-all; @font-face 规则123456@font-face&#123; font-family: myFirstFont; src: url(sansation_bold.woff); font-weight:bold;&#125; 2D 转换translate()123transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */ rotate()123transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */ scale()123-ms-transform:scale(2,3); /* IE 9 */-webkit-transform: scale(2,3); /* Safari */transform: scale(2,3); /* 标准语法 */ skew()123transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ matrix()123transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ 3D方法rotateX()12transform: rotateX(120deg);-webkit-transform: rotateX(120deg); /* Safari 与 Chrome */ rotateY() 过渡12transition: width 2s, height 2s, transform 2s;-webkit-transition: width 2s, height 2s, -webkit-transform 2s; 所有属性123456789transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;/* Safari */-webkit-transition-property:width;-webkit-transition-duration:1s;-webkit-transition-timing-function:linear;-webkit-transition-delay:2s; @keyframes 规则动画123456789101112131415161718192021222324252627282930313233343536// 应用div&#123; animation: myfirst 5s linear 2s infinite alternate; /* Safari 与 Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate;&#125;// 简写@keyframes myfirst&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari 与 Chrome */&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;// 详细@keyframes myfirst&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari 与 Chrome */&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125; 多列column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width 用户界面resize1resize:both; box-sizing12box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */ outline-offset1outline-offset:10px; 弹性盒子(Flex Box)传送门 媒体查询12345@media screen and (min-width: 480px) &#123; body &#123; background-color: lightgreen; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"JS原生on和addEventListener优缺点","slug":"JS原生on和addEventListener优缺点","date":"2017-10-19T15:29:51.000Z","updated":"2017-10-19T15:38:06.527Z","comments":true,"path":"2017/10/19/JS原生on和addEventListener优缺点/","link":"","permalink":"/2017/10/19/JS原生on和addEventListener优缺点/","excerpt":"一直以来编程的时候对on和addEventListener的选择摇摆不定，这里稍微理清下知识点，解决实际开发中语句选择问题。","text":"一直以来编程的时候对on和addEventListener的选择摇摆不定，这里稍微理清下知识点，解决实际开发中语句选择问题。 转载 为什么需要addEventListener？ 先来看一个片段： html代码1&lt;div id=\"box\"&gt;vinson-sheep&lt;/div&gt; 用on的代码1234567891011window.onload = function()&#123; var box = document.getElementById(\"box\"); box.onclick = function()&#123; console.log(\"我是box1\"); &#125; box.onclick = function()&#123; box.style.fontSize = \"18px\"; console.log(\"我是box2\"); &#125;&#125; 运行结果：“我是box2” 看到了吧，第二个onclick把第一个onclick给覆盖了，虽然大部分情况我们用on就可以完成我们想要的结果，但是有时我们又需要执行多个相同的事件，很明显如果用on完成不了我们想要的，那不用猜，你们肯定知道了，对！addEventListener可以多次绑定同一个事件并且不会覆盖上一个事件。 用addEventListener的代码1234567891011window.onload = function()&#123; var box = document.getElementById(\"box\"); box.addEventListener(\"click\",function()&#123; console.log(\"我是box1\"); &#125;) box.addEventListener(\"click\",function()&#123; console.log(\"我是box2\"); &#125;)&#125; 运行结果：我是box1 我是box2 addEventListenert方法第一个参数填写事件名，注意不需要写on，第二个参数可以是一个函数，第三个参数是指在冒泡阶段还是捕获阶段处理事件处理程序,如果为true代表捕获阶段处理,如果是false代表冒泡阶段处理，第三个参数可以省略，大多数情况也不需要用到第三个参数,不写第三个参数默认false 第三个参数的使用 有时候的情况是这样的:12345&lt;body&gt; &lt;div id=\"box\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 如果我给box加click事件，如果我直接单击box没有什么问题，但是如果我单击的是child元素，那么它是怎么样执行的？（执行顺序）12345678910box.addEventListener(\"click\",function()&#123; console.log(\"box\");&#125;)child.addEventListener(\"click\",function()&#123; console.log(\"child\");&#125;) 执行的结果： child box 也就是说，默认情况事件是按照事件冒泡的执行顺序进行的。 如果第三个参数写的是true，则按照事件捕获的执行顺序进行的。 事件冒泡执行过程： 从最具体的的元素（你单击的那个元素）开始向上开始冒泡，拿我们上面的案例讲它的顺序是：child-&gt;box 事件捕获执行过程： 从最不具体的元素（最外面的那个盒子）开始向里面冒泡，拿我们上面的案例讲它的顺序是：box-&gt;child 以上这篇全面了解addEventListener和on的区别就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。 参考文章——全面了解addEventListener和on的区别","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}]},{"title":"Javascript中defer和async","slug":"Javascript中defer和async","date":"2017-10-15T16:29:54.000Z","updated":"2017-10-15T16:57:40.831Z","comments":true,"path":"2017/10/16/Javascript中defer和async/","link":"","permalink":"/2017/10/16/Javascript中defer和async/","excerpt":"说实话defer和async属性是很少时候会用上。这篇文章就是讲述它如何如何难被用上。","text":"说实话defer和async属性是很少时候会用上。这篇文章就是讲述它如何如何难被用上。 知识点文档解析在web中指的是html文档被下载后由浏览器引擎解析为DOM节点树的过程。 阻塞在web是指html文档解析受阻。当一个http请求被响应，首先下载html文件，再解析html文件。也就是说，html文件是肯定会被下载的，但是解析可能会受阻。 这里引用犀牛书的一段话： 当HTML解析器遇到&lt;script&gt;元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。这对于内联脚本没什么问题（这里大概是指不需要下载直接执行），但如果脚本源代码是一个由src属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。 作者在这里的表述很模糊，所谓“不会出现在浏览器中”，是指文档的文本内容已经载入，但是未被浏览器引擎解析为DOM树，而DOM树的生成是受Javascript代码执行的影响的，Javascript代码会“阻塞”页面UI的渲染。 脚本的执行只在默认情况下是同步和阻塞的。 defer和async12&lt;script defer src=\"deferred.js\"&gt;&lt;/script&gt;&lt;script async src=\"async.js\"&gt;&lt;/script&gt; defer和async属性都像在告诉浏览器链接进来的脚本不会使用document.write()，也不会生成文档内容，因此浏览器可以在下载脚本时候继续解析和渲染文档。 defer属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。 async属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。 如果&lt;script&gt;标签同时有两个属性，同时支持两者的浏览器会遵从async属性并忽略defer属性。 分析无论是defer和async属性，只有在脚本下载过程中可能阻塞文档解析的过程中才能够发挥作用，意味着&lt;script&gt;元素需要出现在文档一般元素之前（非html和body元素）。 在html和Javascript代码分离的哲学思想下，我们大多会把&lt;script&gt;元素放在文档底部，html和body元素之前。这时候defer和async属性就不能发挥作用了，因为js是同步解析的，当解析到&lt;script&gt;时，整个DOM树几乎已经解析完毕，并且渲染完成。 总的来讲，这两个元素用得不多，当&lt;script&gt;放在head时可能会用上。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"html+css+js前端学习网站推荐","slug":"html-css-js前端学习网站推荐","date":"2017-10-14T14:52:17.000Z","updated":"2017-10-14T14:58:08.348Z","comments":true,"path":"2017/10/14/html-css-js前端学习网站推荐/","link":"","permalink":"/2017/10/14/html-css-js前端学习网站推荐/","excerpt":"推荐一些前端学习网站。","text":"推荐一些前端学习网站。 自学前端快一年了，就在这和大伙儿稍做分享吧。 HTML&amp;CSS学习网站： W3schoolhttp://www.w3school.com.cn/index.html 这个不用多介绍 30天学习HTML&amp;CSShttp://webdesign.tutsplus.com/courses/30-days-to-learn-html-css 有视频，但是英文水平需要高 前端人的俱乐部http://f2er.club/ 感觉还不错，虽然我不经常上 编码规范http://zoomzhao.github.io/code-guide/ 编码规范很重要 在你有了一定的HTML&amp;CSS基础后，我再介绍以下网站： CSS3动画http://webdesign.tutsplus.com/tutorials/creating-a-collection-of-css3-animated-pre-loaders--cms-21978 csdn博客http://m.blog.csdn.net/Column/Index?Channel=web&amp;Type=New w3chttp://www.w3cplus.com/ 空智-博客园http://www.cnblogs.com/tugenhua0707/ 智能社的视频教程http://www.zhinengshe.com/video.html dowebokhttp://www.dowebok.com/ 主要是jQuery githubhttps://github.com/ 这个不用说 codepenhttp://codepen.io/ 我超喜欢的一个网站 到了这里，你也许想动手建个属于自己的网页，你又想问有哪些漂亮的网页？ reeoohttp://reeoo.com/ 超多漂亮的网页 httpsterhttp://httpster.net/ 你或许还想要些psd文件： http://www.uipixels.com/page/2/ http://www.bestpsdfreebies.com/ 作者：小老师链接：https://www.zhihu.com/question/46939006/answer/103731361来源：知乎","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"学习指导","slug":"学习指导","permalink":"/tags/学习指导/"}]},{"title":"js中RegExp引用方法详解","slug":"js中RegExp引用方法详解","date":"2017-10-14T10:43:13.000Z","updated":"2017-10-14T11:10:32.754Z","comments":true,"path":"2017/10/14/js中RegExp引用方法详解/","link":"","permalink":"/2017/10/14/js中RegExp引用方法详解/","excerpt":"归纳总结一些能够引用RegExp的方法，包括正则表达式对象的属性。","text":"归纳总结一些能够引用RegExp的方法，包括正则表达式对象的属性。 String方法 search() replace() match() split() RegExp对象属性 source global ingoreCase multiline lastIndex RegExp对象方法 exec() test() 详解lastIndexlastIndex是一个可读/可写的整数。在全局模式下使用exec()或者test()，会调用lastIndex属性，如果它找到一个匹配结果，那么它就立即设置lastIndex为当前匹配字串的结束位置。 exec()和test()其实这两个函数行为是一致的，在全局模式g下能够引用RegExp对象的lastIndex属性。我们可以看下面的例子：12345678910// 定一个字符串var s = \"123\";// 声明一个正则表达式var pattern = /\\d/g;// 匹配的是1，返回truepattern.test(s);// 匹配的是2，返回\"2\"pattern.exec(s)// lastIndex经过两次递增后为2pattern.lastIndex; // =&gt; 2 值得注意的是，全局模式下使用test()或者exec()时，如果没有匹配到任何内容，则返回null，同时lastIndex会自动刷新为0。当然lastIndex是可以显示更改的。 exec()和match()这两个函数在没有匹配项的时候会返回null，否则一律返回数组，即使只有一个匹配项。 exec()不能够一次得到所有匹配项。如果需要获取字符串所有的匹配项，需要在全局模式g下使用循环，这时候函数会自动调用lastIndex属性。当函数返回为null，证明已经遍历了整个字符串。 match()能够一次得到一个由所有匹配项得到的数组。分组()只要不影响正则表达式的逻辑，不会对输出结果个数造成影响。1234// 无分组\"abcabc\".match(/abc/g); // =&gt; [\"abc\", \"abc\"]// 分组\"abcabc\".match(/(abc)/g); // =&gt; [\"abc\", \"abc\"] 综合地说，exec()适合获取分组，match()适合一次获取所有的匹配项。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"}]},{"title":"js正则表达式的多行模式和单行模式","slug":"js正则表达式的多行模式和单行模式","date":"2017-10-14T07:05:42.000Z","updated":"2017-10-14T08:05:42.914Z","comments":true,"path":"2017/10/14/js正则表达式的多行模式和单行模式/","link":"","permalink":"/2017/10/14/js正则表达式的多行模式和单行模式/","excerpt":"参考了一些文章，对js正则表达式的多行模式和单行模式有了更深的了解。","text":"参考了一些文章，对js正则表达式的多行模式和单行模式有了更深的了解。 引言其实底部的文章已经把多行模式和单行模式的关系讲述得很透彻了，但是它是针对php和Expresso，在js环境下的正则表现会有差异。多行模式在犀牛书的描述其实也是相当简洁明了的： 修饰符“m”用以在多行模式中执行匹配，在这种模式下，如果检索的字符串包含多行，那么^和$锚字符除了匹配整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。 书上这么说，但到底是怎么一种情况呢？ 文本保存的方式首先我们来思考一个问题，当我们在win上的txt文本上敲一个回车然后保存，那文件对回车的保存是如何实现的？ 比如我在这输入点东西 知识点：\\r为回车符，\\n为换行符。 在windows中，我们平常说的换行，实质上是先回车，后换行。 所以上图的文本等价于1abcde\\r\\n2abc\\r\\n3eeeee\\r\\n。 我们可以基于上面的讨论，在js中模拟多行文本。 测试真实的测试是需要调用本地或者网络文件，读取里面的内容再进行多行匹配。 为了便于测试，我们使用1abcde\\r\\n2abc\\r\\n3eeeee\\r\\n进行测试。 下面的测试代码：1234567891011&lt;script type=\"text/javascript\"&gt; var pattern = /^(\\d\\w+)$/mg; var item = \"1abcde\\r\\n2abc\\r\\n3eeeeee\"; var item1 = \"1abcde\\n2abc\\n3eeeeee\"; var item2 = \"1abcde\\r2abc\\r3eeeeee\"; console.log(item.match(pattern)); console.log(item1.match(pattern)); console.log(item2.match(pattern));&lt;/script&gt; 输出结果：[&quot;1abcde&quot;, &quot;2abc&quot;, &quot;3eeeeee&quot;] 分析： 如果你阅读了尾部的文章，你会发现输出结果差异非常大，后面会讨论这个问题。在这个例子中，我们分别测试了混合使用\\r\\n与单独使用\\r和\\n的情况，结果输出均为[&quot;1abcde&quot;, &quot;2abc&quot;, &quot;3eeeeee&quot;]。这表明，js多行模式下，\\n和\\r表现是相同的，^和$这两个锚元素都可以定位\\n和\\r前后。 对 . 符号的影响我们将上面的代码修改一下：123456789&lt;script type=\"text/javascript\"&gt; var pattern = /^.$/gm; var item = \"a\"; var item1 = \"\\n\"; var item2 = \"\\r\"; console.log(item.match(pattern)); console.log(item1.match(pattern)); console.log(item2.match(pattern));&lt;/script&gt; 输出结果：[&quot;a&quot;]、null、null。 那是不是表明多行模式下.不能匹配\\n\\r呢？别急，我们将代码再改改：1var pattern = /^.$/g; 输出结果：[&quot;a&quot;]、null、null。 结果令人有点惊讶，单双行模式下.的表现是一致的。如果查看尾部文章，可以发现测试结果与尾部文章的差异甚大。 为什么要做这个测试？因为参考文章提及到这个问题 结论 多行模式会影响^和$的匹配，而且对\\n和\\r的表现是一样的。 正则表达式中的.符号是不能够匹配\\n和\\r，无论是单行还是多行模式下。 php和Expresso对正则的实现与js的差异非常大，要理解语言的特殊性。 传送门： 正则表达式的多行模式与单行模式","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"}]},{"title":"markdown语法复习","slug":"markdown语法复习","date":"2017-10-13T21:04:23.000Z","updated":"2017-10-13T21:14:05.871Z","comments":true,"path":"2017/10/14/markdown语法复习/","link":"","permalink":"/2017/10/14/markdown语法复习/","excerpt":"最近写文章的时候老需要用markdown写表格的情况，一想到markdown表格需要很多|和-我就头疼了。写篇文章复习下。","text":"最近写文章的时候老需要用markdown写表格的情况，一想到markdown表格需要很多|和-我就头疼了。写篇文章复习下。 标题123# 一级标题## 二级标题### 三级标题 列表12345678910111.2.3.- a- b- c* a* b* c 引用1&gt; aaa 图片与链接123![]()&#123;ImgCap&#125;&#123;/ImgCap&#125;[]() 粗体与斜体12**strong***italic* 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | :不同位置代表不同的对齐方式。 参考文章:Markdown——入门指南","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"/tags/markdown/"}]},{"title":"JS正则表达式RegExp语法","slug":"JS正则表达式RegExp语法","date":"2017-10-13T19:49:35.000Z","updated":"2017-10-13T21:00:56.405Z","comments":true,"path":"2017/10/14/JS正则表达式RegExp语法/","link":"","permalink":"/2017/10/14/JS正则表达式RegExp语法/","excerpt":"JS的正则表达式实际上是一套精密的选择器。实际上各种语言的正则表达式都十分相似，但当正则放在JS实现上就有细微的差异，这些差异会在文章中略微谈到。","text":"JS的正则表达式实际上是一套精密的选择器。实际上各种语言的正则表达式都十分相似，但当正则放在JS实现上就有细微的差异，这些差异会在文章中略微谈到。 文章大部分摘录自犀牛书 javascript中正则表达式使用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象，不过RegExp对象更多是通过一种特殊的直接量语法来创建。1var pattern = /s$/; 语法直接量字符 字符 匹配 字母和数字字符 自身 \\o NUL字符（\\u0000） \\t 制表符（\\u0009） \\n 换行符（\\u000A） \\v 垂直制表符（\\u000B） \\f 换页符（\\u000C） \\r 回车符（\\u000D） \\xnn 由十六进制数nn指定的拉丁字符，例如，\\x0A等价于\\n \\cX 控制字符^X，例如，\\cJ等价于换行符\\n 在正则表达式中，许多标点符号具有特殊含义，它们是： ^ $ . * ? = ! : \\ / ( ) [ ] { } 表格中经常使用的应该是\\n,\\r。 字符类[]将直接量字符串单独放进方括号内就组成了字符类。 注意，有些字符类转义字符只能匹配ASCII字符，还没扩展到可以处理Unicode字符，但可以通过十六进制表示方法来显式定义Unicode字符类。 字符 匹配 […] 方括号内任意字符 [^…] 不在方括号内的任意字符 . 除换行符和其他Unicode行终止符之外的任意字符 \\w 任何ASCII字符组成的单词，等价于[a-zA-Z0-9] \\W 等价于[^a-zA-Z0-9] \\s 任何Unicode空白符 \\S 任何非Unicode空白符的字符，注意\\w和\\S不同 \\d 任何ASCII数字，等价于[0-9] \\D 除了ASCII数字之外的任何字符，等价于[^0-9] [\\b] 退格直接量(特例) 重复{} 字符 匹配 {n,m} 匹配前一项至少n次，但不能超过m次 {n,} 匹配前一项n次或者更多次 {n} 匹配前一项n次 ? {0,1} + {1,} * {0,} 非贪婪的重复上表列出的匹配重复字符是尽可能地多匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为“贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只须在等匹配的字符后跟随一个问号即可：“??”、“+?”、“*?”或者“{1,5}?”。比如，正则表达式/a+/可以匹配一个或多个连续的字幕a。当使用“aaa”作为匹配时，正则表达式会匹配它的三个字符。但是/a+?/也可以匹配一个或多个连续字母a，但它尽可能少地匹配。我们同样将“aaa”作为匹配字符串，但后一个模式只能匹配一个a。 选择|、分组()和引用$选择|字符“|”用于分隔供选择的字符。例如，/ab|cd|ef/可以匹配字符串“ab”，也可以匹配字符串“cd,还可以匹配字符串“ef”。 分组()正则表达式中的圆括号有多种作用。 第一个作用是单独的项组合成子表达式，以便可以像处理一个独立的单元那样用“|”、“*”、“+”或者“?”等来对单元内的项进行处理。 圆括号的另一个作用是在完整的模式中定义子模式。 最后一个作用是允许在同一正则表达式的后部引用前面的子表达式。 关于最后一个作用：1/(['\"])[^'\"]*\\1/ \\1是对([&#39;&quot;])的引用。 值得注意的是，对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。所以，假如([&#39;&quot;])匹配到&quot;，则\\1指代的是&quot;，而不能是&#39;。 字符 含义 一竖 选择符 (…) 分组 (?:…) 只组合，把项组合到一个单元，但不记忆与改组相匹配的字符 引用$像\\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。**最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。 字符 含义 ^ 匹配开头，在多行检索中，匹配一行的开头 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾 \\b 匹配边界 \\B 匹配非边界 (?=p) 零宽正向先行断言 (?!p) 零宽负向先行断言 具体看犀牛书p260~261 特别需要注意的是，js是不支持(?!p)。 \\b指代位于字符\\w和\\W之间的位置。 修饰符1/\\bjava\\b/i 修饰符“i”用以说明模式匹配是不区分大小写的。修饰符“g”说明模式匹配应该是全局的，也就是说，应该找出被检索字符串中所有的匹配。修饰符“m”用以在多行模式中执行匹配，在这种模式下，如果待检索的字符串包含多行，那么^和$锚字符除了匹配整个字符串的开头和结尾之外，还能匹配每行的开始和结尾。 关于多行模式，我会在下一篇文章中详解。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"}]},{"title":"ES3和ES5中RegExp实例创建差异","slug":"ES3和ES5中RegExp实例创建差异","date":"2017-10-13T13:56:51.000Z","updated":"2017-10-13T14:13:56.970Z","comments":true,"path":"2017/10/13/ES3和ES5中RegExp实例创建差异/","link":"","permalink":"/2017/10/13/ES3和ES5中RegExp实例创建差异/","excerpt":"犀牛书中揭示了不同ES标准下RegExp实例创建的差异，虽然这种差异是很难被应用在实际开发中的。不过了解一下也无妨。","text":"犀牛书中揭示了不同ES标准下RegExp实例创建的差异，虽然这种差异是很难被应用在实际开发中的。不过了解一下也无妨。 12// 正则表达式直接量var pattern = /s$/ 正则表达式直接量,ECMAScript 3规范规定，一个正则表达式直接量会在执行到它的时候转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所代表的正则表达式直接量的每次运算都返回新对象。IE一直都是按照ECMAScript 5规范实现的，多数最新版本的浏览器也开始遵循ECMAScript 5，尽管目前该标准并未全面广泛推行。 要知道犀牛书已经很旧了，实际上主流的浏览器几乎都遵循ES 5，有的甚至全面实现ES 6。 犀牛书的作者在这里揭示了一种非常容易忽略的情况，比如，这段代码在Firefox 3.6和Firefox 4+中运行结果不一致：1234567891011function getRE() &#123; var re = /[a-z]/; re.foo = \"bar\"; return re;&#125;var reg = getRE(), re2 = getRE();console.log(reg == re2); // 在Firefox .6中返回true，在Firefox 4+中返回falsereg.foo = \"bar\";console.log(re2.foo); // 在Firefox 3.6中返回\"baz\"，在Firefox 4+返回\"bar\" 原因可以在ECMAScript 5规范第24页和第247页找到，也就是说在ECMAScript 3规范中，用正则表达式创建的RegExp对象会共享同一个实例，而在ECMAScript 5中则是两个独立的实例。而最新的Firefox 4、Chrome和Safari 5都遵循ECMAScript 5标准，以至于IE6~IE8都没有很好地遵循ECMAScript 3标准，不过在这个问题上反而处理对了。很明显ECMAScript 5的规范更符合开发者的期望。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"},{"name":"ES标准","slug":"ES标准","permalink":"/tags/ES标准/"}]},{"title":"JS实现无限分页加载——原理图解(转)","slug":"JS实现无限分页加载——原理图解-转","date":"2017-10-13T03:45:54.000Z","updated":"2017-10-13T16:12:00.653Z","comments":true,"path":"2017/10/13/JS实现无限分页加载——原理图解-转/","link":"","permalink":"/2017/10/13/JS实现无限分页加载——原理图解-转/","excerpt":"由于网页的执行都是单线程的，在JS执行的过程中，页面会呈现阻塞状态。因此，如果JS处理的数据量过大，过程复杂，可能会造成页面的卡顿。传统的数据展现都以分页的形式，但是分页的效果并不好，需要用户手动点击下一页，才能看到更多的内容。有很多网站使用 无限分页 的模式，即网页视窗到达内容底部就自动加载下一部分的内容…本篇就无限分页的实现模型，讲述其中奥妙。","text":"由于网页的执行都是单线程的，在JS执行的过程中，页面会呈现阻塞状态。因此，如果JS处理的数据量过大，过程复杂，可能会造成页面的卡顿。传统的数据展现都以分页的形式，但是分页的效果并不好，需要用户手动点击下一页，才能看到更多的内容。有很多网站使用 无限分页 的模式，即网页视窗到达内容底部就自动加载下一部分的内容…本篇就无限分页的实现模型，讲述其中奥妙。 原理图实现无限分页的过程大致如下： 视窗滚动到底部 触发加载，添加到现有内容的后面。 因此，可能会出现两种情况： 当页面的内容很少，没有出现滚动条。 当页面的内容很多，出现了滚动条。 针对这两种情况，需要理解几个概念： scrollHeight即真实内容的高度； clientHeight比较好理解，是视窗的高度，就是我们在浏览器中所能看到内容的高度； scrollTop是视窗上面隐藏掉的部分 实现的思路1. 如果真实的内容比视窗高度小，则一直加载到超过视窗2. 如果超过了视窗，则判断下面隐藏的部分的距离是否小于一定的值，如果是，则触发加载。（即滚动到了底部） 代码样例代码部分没有太多的内容，需要注意的是：1. 使用fixed定位加载框2. 使用setTimeout定时触发判断方法，频率可以自定义3. 通过 真实内容高度 - 视窗高度 - 上面隐藏的高度 &lt; 20，作为加载的触发条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;无限翻页测试&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; #spinner&#123; position: fixed; top: 20px; left: 40%; display: block; color: red; font-weight: 900; background-color: rgba(80, 80, 90, 0.22); padding-top: 20px; padding-bottom: 20px; padding-left: 100px; padding-right: 100px; border-radius: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sample\"&gt; &lt;/div&gt; &lt;div id=\"spinner\"&gt; 正在加载 &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var index = 0; function lowEnough()&#123; var pageHeight = Math.max(document.body.scrollHeight,document.body.offsetHeight); var viewportHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0; var scrollHeight = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; // console.log(pageHeight); // console.log(viewportHeight); // console.log(scrollHeight); return pageHeight - viewportHeight - scrollHeight &lt; 20; &#125; function doSomething()&#123; var htmlStr = \"\"; for(var i=0;i&lt;10;i++)&#123; htmlStr += \"这是第\"+index+\"次加载&lt;br&gt;\"; &#125; $('#sample').append(htmlStr); index++; pollScroll();//继续循环 $('#spinner').hide(); &#125; function checkScroll()&#123; if(!lowEnough()) return pollScroll(); $('#spinner').show(); setTimeout(doSomething,900); &#125; function pollScroll()&#123; setTimeout(checkScroll,1000); &#125; checkScroll(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 个人总结 触发加载的条件始终是：真实内容高度 - 视窗高度 - 上面隐藏的高度 &lt; 20，只要把握好scrollHeight、scrollTop等属性就可以手动从写代码。 index加载内容变化的关键，如果需要让服务器返回数据，诸如评论内容等，将index提交给服务器，作为一组数据的索引。如果所有内容加载完毕，则将index设置为特定值，这样使用js就能够不再触发加载。 例子中使用了setTimeout,个人觉得使用setInterval会更好懂一些。但是它使用setTimeout也是很精妙，通过函数对这setTimeout互相调用，达到setInterval相同的效果。 本文精华所在是pageHeight、viewportHeight、scrollHeight的定义，尽管我觉得它命名上很不符合语义，但是代码还是相当严密。 document.documentElement.scrollTop在chrome是永远返回0的。 传送门： JS实现无限分页加载——原理图解","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"前端组件开发","slug":"前端组件开发","permalink":"/tags/前端组件开发/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}]},{"title":"Javascript浏览器中的各种xxxHeight属性详解","slug":"Javascript浏览器中的各种xxxHeight属性详解","date":"2017-10-12T15:48:16.000Z","updated":"2017-10-12T16:55:27.864Z","comments":true,"path":"2017/10/12/Javascript浏览器中的各种xxxHeight属性详解/","link":"","permalink":"/2017/10/12/Javascript浏览器中的各种xxxHeight属性详解/","excerpt":"曾经一度被浏览器中的各种高度弄得头晕眼花，今天特意查询了这方面的内容，终于搞懂了，决定写篇文章纪念一下scrollHeight、clientHeight、offsetHeigh、scrollTop、window.innerHeight、window.pageYOffset。","text":"曾经一度被浏览器中的各种高度弄得头晕眼花，今天特意查询了这方面的内容，终于搞懂了，决定写篇文章纪念一下scrollHeight、clientHeight、offsetHeigh、scrollTop、window.innerHeight、window.pageYOffset。 博主原创 文章提要： 滑动条的高度或宽度为17px 这里讨论的xxxHeight返回的都是数值 文章是以chrome测试作为结果，其他浏览器的说明是通过其他文章的描述总结得出。 通用属性1. scrollHeightscrollHeight表示的是滑动条内可滑动的内容。 如果内容没有超出元素高度，那么scrollHeight表示的是元素的height加上padding，不包括bording。 如果内容超出了元素高度但没有设置滑动条，那么scrollHeight表示的是元素height加上元素的上padding（scrollWidth为左padding），不包括下padding和bording。 如果内容超出了元素高度并且设置有滑动条，那么scrollHeight表示的是滑动条可滑动的高度，不包括滑动条自身的高度（17px）。 我们来测试一下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;style type=\"text/css\"&gt; #test &#123; width: 50px; border: 5px solid green; background-color: black; color: red; padding: 10px; overflow: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"test\"&gt; &lt;span&gt;clientHeight:可见区域的宽度,不包括boder的宽度,如果区域内带有滚动条,还应该减去横向滚动条不可用的高度,正常的是17px &lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var test = document.getElementById(\"test\"); console.log(\"scroll=\" + test.scrollHeight+ \";client=\" + test.clientHeight + \";offset=\" + test.offsetHeight)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面是测试结果： chrome测试结果 console输出结果 分析： 这里的例子是利用一些巧妙的方法，使保证内容全部显示的同时保持滑动条的存在。从图中我们可以看到，元素总导高度为551px，那么scrollHeight的数值到底是怎么算出来的呢？首先是上下border一共10px，再加上滑动条高度的17px一共27px，于是551-27=524。 最后引用其他博主的文字： scrollHeight:这个属性就比较麻烦了,因为它们在火狐跟IE下简直差太多了..在火狐下还很好理解,它其实就是滚动条可滚动的部分还要加上boder的高度还要加上横向滚动条不可用的高度,与clientHeight比起来,多个border的高度跟横向滚动条不可用的高度. 在IE中 scrollHeight确是指这个对象它所包含的对象的高度加上boder的高度和marging,如果它里面没有包含对象或者这个对象的高度值未设置,那么它的值将为15 2. clientHeight这个属性等于元素内容高度height加上padding。 这个元素没什么好说的，各种浏览器下表现一样。 3. offsetHeight这个属性表示元素内容高度height加上padding再加上border，但不包括margin。 4. scrollTop这个属性表示视窗上面隐藏了部分的高度。 常用的语句是：document.body.scrollTop和document.documentElement.scrollTop 值得注意的一点是，chrome不承认document.documentElement.scrollTop，或者说，它永远返回数值0。 浏览器对象属性1. window.innerHeight返回浏览器窗口高度。 2. window.pageYOffset数值和document.body.scrollTop一致，表示视窗上面隐藏了部分的高度。 参考文章： JS实现无限分页加载——原理图解 height、clientHeight、scrollHeight、offsetHeight区别 Chrome不认documentElement.scrollTop","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js客户端对象","slug":"js客户端对象","permalink":"/tags/js客户端对象/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"}]},{"title":"Javascript类型的判断","slug":"Javascript类型的判断","date":"2017-10-08T14:26:53.000Z","updated":"2017-10-08T15:39:37.451Z","comments":true,"path":"2017/10/08/Javascript类型的判断/","link":"","permalink":"/2017/10/08/Javascript类型的判断/","excerpt":"js对象的类型和类的判断，会让你头晕眼花的，起码我是这样。这篇文章通过原生和非原生的函数，将各种数据的类型和类检测出来，其中涉及到“鸭式辩型”的概念。","text":"js对象的类型和类的判断，会让你头晕眼花的，起码我是这样。这篇文章通过原生和非原生的函数，将各种数据的类型和类检测出来，其中涉及到“鸭式辩型”的概念。 博主原创 typeof()我们首先来看一下实例：1234567891011121314151617typeof undefined // =&gt; \"undefined\"typeof true // =&gt; \"boolean\"typeof NaN // =&gt; \"number\"typeof \"abc\" // =&gt; \"string\"typeof(function()&#123;&#125;) // =&gt; \"function\"typeof null // =&gt; \"object\"typeof &#123;&#125; // =&gt; \"object\"typeof [] // =&gt; \"object\"typeof(new Date) // =&gt; \"object\"typeof(/./） // =&gt; \"object\"typeof window // =&gt; \"object\"// 自定义对象function f(name) &#123; this.name=name; &#125;var fo = new f(\"vinson\");typeof fo; // =&gt; \"object\" 从上面实例可以看到，使用js原生的运算符typeof，能分辨大部分的基本数据类型，但不能分辨类，即class。对于涉及原型链上的类，它一律返回”object”。 更重要的是，面对大部分内置对象（除了function），它依然返回object。比如在JS中，Array类是继承于Object的，所以Array原型的原型链中最终指向于Object。显然，这与我们的预期不符。 但是函数function却能返回，这不是很过分吗？ 基于上面的分析，我们编写了下一个更缜密的函数classof()，检查类属性。 注意，类型type和类class是不同的概念。 资料参考《Javascript权威指南》p87~88 classof()对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3和ECMAScript 5都未提供设置这个属性的方法，并且只有一种间接的方法可以查询它。默认的toString()方法（继承自Object.prototype）返回了如下这种格式的字符串：1[object class] 因此，要想获得对象的类，可以调用对象的toString()方法，然后提取已返回字符串的第8个到倒数第二个位置之间的字符。不过让人感到棘手的是，很多对象继承的toString()方法重写了，为了能调用正确的toString()版本，必须简介地调用Function.call()方法。下面是classof的实现：123456// classof()函数function classof(o) &#123; if (o === null) return \"Null\"; if (o === undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 下面是这个函数的实例：1234567891011classof(null) // =&gt; \"Null\"classof(1) // =&gt; \"Number\"classof(\"\") // =&gt; \"String\"classof(false) // =&gt; \"Boolean\"classof(&#123;&#125;) // =&gt; \"Object\"classof([]) // =&gt; \"Array\"classof(/./) // =&gt; \"Regexp\"classof(new Date()) // =&gt; \"Date\"classof(window) // =&gt; \"Window\"（这是客户端宿主对象）function f() &#123;&#125;; // 定义一个自定义构造函数classof(new f()); // =&gt; \"Object\" 通过classof()函数，我们能够分辨出除了继承对象之外的所有基本类型和内置对象。 对比typeof()函数可以发现，classof()返回的字符串都是以大写开头的。 资料参考《Javascript权威指南》p139~140 type()自定义的对象都不能通过上面的两个方法分辨出来，我们需要一种更精细的方法来检测对象的类。这里的类指的是构造函数的名称。 我们可以通过通过constructor属性获取函数对象，再将函数对象转换为字符串，从中获取构造函数的名称，即类名称。下面是完整的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 以字符串的形式返回o的类型 * - 如果o是null，返回\"null\";如果o是NaN，返回\"nan\" * - 如果typeof所返回的值不是\"object\"，则返回这个值 * - (注意，有一些Javascript的实现将正则表达式识别为函数) * - 如果o的类不是\"Object\"，则返回这个值 * - 如果o包含构造函数并且这个构造函数具有名称，则返回这个名称 * - 否则，一律返回\"Object\" **/function type(o) &#123; var t,c,n; // type,class,name //处理null值的特殊情况 if (o === null) return \"null\"; // 另外一种特殊情况:NaN和它自身不相等 if (o !== o) return \"nan\"; //如果typeof的值不是\"object\"，则返回这个值 if((t = typeof o) !== \"Object\") return c; //返回对象的类名，除非值为\"Object\" //这种方式可以识别出大多的内置对象 if((c = classof(o)) !== \"Object\") return c; //如果对象构造函数的名字存在的话，则返回它 if(o.constructor &amp;&amp; typeof o.constructor === \"function\" &amp;&amp; (n = o.construcor.getName())) return n; //其他的类型都无法判别，一律返回\"Object\" return \"Object\";&#125;//返回对象的类function classof(o) &#123; return Object.prototype.toString.call(o).slice(8,-1);&#125;;//返回函数的名字（可能是空字符串），不是函数的话就返回nullFunction.prototype.getName = function () &#123; if (\"name\" in this) return this.name; return this.name = this.toString().match(/function\\s*([^(]*)\\(/)[1];&#125;; 这种使用构造函数来识别对象的类的做法和使用constructor属性一样有一个问题：**并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，getName()方法则会返回空字符串：1234//这个构造函数没有名字var Complex = function(x,y) &#123; this.r = x;this.i = y; &#125;//这个构造函数有名字var Range = function Range(f,t) &#123; this.from = f;this.to = t;&#125; 《Javascript权威指南》p213~214 鸭式辩型上文所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端Javascript中是如此。解决办法就是规避这些问题：不要关注“对象的类是什么”，而是关注“对象能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，成为“鸭式辩型”。 像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。 实例…略 《Javascript权威指南》p215~216","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}]},{"title":"github制作项目DOME方法","slug":"github制作项目DOME方法","date":"2017-10-08T13:49:50.000Z","updated":"2017-10-08T13:54:29.078Z","comments":true,"path":"2017/10/08/github制作项目DOME方法/","link":"","permalink":"/2017/10/08/github制作项目DOME方法/","excerpt":"很多时候我们在github上提交了html文件却苦于不能有个实体DEMO。这里的方法很简单，github是内置这种功能的，只需要将网址调整一下即可。","text":"很多时候我们在github上提交了html文件却苦于不能有个实体DEMO。这里的方法很简单，github是内置这种功能的，只需要将网址调整一下即可。 加入我当时有一个IFE作业，github路径为1https://github.com/Vinson-sheep/IFE2017/blob/master/JS/1/js1.html 那DEMO的网址就是1https://htmlpreview.github.io/?https://github.com/Vinson-sheep/IFE2017/blob/master/JS/1/js1.html","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"Javascript中call和apply","slug":"Javascript中call和apply","date":"2017-10-07T09:01:51.000Z","updated":"2017-10-07T09:10:24.886Z","comments":true,"path":"2017/10/07/Javascript中call和apply/","link":"","permalink":"/2017/10/07/Javascript中call和apply/","excerpt":"我们可以将call()和apply()看作是某个对象的方法，通过调用方法的形式来间接调用函数。","text":"我们可以将call()和apply()看作是某个对象的方法，通过调用方法的形式来间接调用函数。 call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f()，可以这样使用call()和apply()。12f.call(o);f.apply(o); 在ECMAScript 5 的严格模式中，call()和apply()的第一个实参都会变为this的值，哪怕传入的实参是原始值甚至是null或者undefined。在ECMAScript 3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装类型所代替。 call()对于call()来说，第一个调用上下文实参之后的所有实参就是传入待调用函数的值。1f.call(o,1,2); apply()apply()方法和call()类似，但传入实参的形式和call()有所不同，它的实参都放入一个数组当中：1f.apply(o,[1,2]);","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript闭包","slug":"Javascript闭包","date":"2017-10-07T05:32:02.000Z","updated":"2017-10-07T09:00:16.385Z","comments":true,"path":"2017/10/07/Javascript闭包/","link":"","permalink":"/2017/10/07/Javascript闭包/","excerpt":"函数对象可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域呢，这种特性在计算机科学文献中称为“闭包”。","text":"函数对象可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域呢，这种特性在计算机科学文献中称为“闭包”。 “闭包”，这个术语非常古来，是指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量“包裹”了起来。 犀牛书p182~188 作用域链规则来看下这段代码：1234567var scope = \"global\"; // 全局变量function checkscope() &#123; var scope = \"local scope\"; // 局部变量 function f() &#123; return scope; &#125; //在作用域中返回这个值 return f();&#125;checkscope(); // =&gt; \"local scope\" 上面得出local scope应该毫无悬念。 现在我们对这段代码做小改动。1234567var scope = \"global scope\"; // 全局变量function checkscope() &#123; var scope = \"local scope\"; // 局部变量 function f() &#123; return scope; &#125; return f;&#125;checkscope()() // 返回值是什么？ checkscope函数会返回一个内嵌函数，而执行这个引用了局部变量的内嵌函数，返回的是什么呢？不管在何时何地执行函数f()，f()和checkscope()函数的绑定依然有效。因此最后一行代码会返回local scope，而不是global scope。简而言之，闭包的这个特效强大得让人大吃一惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看来像这里变量绑定到了在其中定义它们的外部函数。 私有变量像counter一样的私有变量不是只能用在一个单独的闭包内，在同一个内部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链，看一下这段代码：12345678910111213function counter() &#123; var n = 0; return &#123; count: function() &#123;return n++;&#125;, reset: function() &#123;n=0;&#125; &#125;;&#125;var c = counter(), d = counter(); // 创建两个计数器c.count() // =&gt; 0d.count() // =&gt; 0 : 它们互不干扰c.reset() // reset()和count()方法共享状态c.count() // =&gt; 0d.count() // =&gt; 1: 而没有重置d 循环陷阱先看下面代码：123456789// 这个函数返回一个总是返回v的函数function constfunc(v) &#123;return function() &#123;return v;&#125;;&#125;// 创建一个数组用来储存常数函数var funcs = [];for (var i=0; i&lt;10; i++) funcs[i] = constfunc(i);// 在第5个位置的元素所表示的函数返回值为5funcs[5]() // =&gt; 5 这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：啊就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：12345678910// 返回一个函数组成的数组，它们的返回值是0~9function constfuncs() &#123; var funcs = []; for (var i = 0; i&lt;10; i++) funcs[i] = function() &#123; return i; &#125;; return funcs;&#125;var funcs = constfuncs();func[5]() // 返回值是什么？ 上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当constfuncs()返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”。 注意this是Javascript的关键字，不是变量每个函数调用都包含一个this值，如果闭包在外部函数里是无法访问this的，除非外部函数将this转存为一个变量：1var self = this; // 将this保存至一个变量中，以便嵌套的函数能够访问它 arguments并不是关键字arguments并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的arguments，因此闭包无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另一个变量中：1var outerArguments = argumens; // 保存起来以便嵌套的函数能够使用它","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js闭包","slug":"js闭包","permalink":"/tags/js闭包/"}]},{"title":"Javascript作为命名空间的函数","slug":"Javascript作为命名空间的函数","date":"2017-10-06T16:45:32.000Z","updated":"2017-10-06T16:55:03.715Z","comments":true,"path":"2017/10/07/Javascript作为命名空间的函数/","link":"","permalink":"/2017/10/07/Javascript作为命名空间的函数/","excerpt":"在函数中声明的变量在整个函数体内都是可见的（包括嵌套的函数中），在函数的外部都是不可见的。我们常常简单地定义一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。","text":"在函数中声明的变量在整个函数体内都是可见的（包括嵌套的函数中），在函数的外部都是不可见的。我们常常简单地定义一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。 我记得《Javascript高级程序设计》中也提及到这方面的内容，但是我觉得《Javascript权威指南》对这方面描述得更为清晰。 比如，假设你写了一段Javascript模块代码，这段代码将要用在不同的Javascript程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样的问题就来了，当模块代码放在不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么就会和代码冲突。解决方法当然是将代码放入一个函数内，然后调用这个函数：123456function mymodule() &#123; // 模块代码 // 这个代码所使用的所有变量都是局部变量 // 而不是污染全局命名空间&#125;mymodule(); // 别忘了还要调用这个函数 这样做还是太麻烦了，我们可以直接定义一个匿名函数，并在单个表达式中调用它：123(function() &#123; // 模块代码&#125;()); // 结束函数定义并立即调用它 相比于第一种方案，我更倾向于第二种方案。第二种方案起码避免一个函数名称冲突的可能。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript自定义函数属性","slug":"Javascript自定义函数属性","date":"2017-10-06T16:45:14.000Z","updated":"2017-10-06T17:07:14.720Z","comments":true,"path":"2017/10/07/Javascript自定义函数属性/","link":"","permalink":"/2017/10/07/Javascript自定义函数属性/","excerpt":"Javascript中函数不是一个原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。","text":"Javascript中函数不是一个原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。 这是个新大陆，利用好的话可以简化很多代码。当然这不是什么高端函数，这个大陆只是一种思维。 比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个函数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放在一个全局变量中，但这并不是必须的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：12345678910// 初始化函数对象的计数属性// 由于函数声明提前了，因此这里是可以函数声明// 之前给它的成员赋值的uniqueInteger.counter = 0;// 每次调用这个函数都会返回一个不同的整数// 它使用一个属性来记住下一次将要返回的值function uniqueInteger() &#123; return uniqueInteger.counter+; // 先返回计数器的值，然后计数器自增1&#125; 来看另一个例子，下面这个函数factorial()使用了自身的属性（将自身当作数组来对待）来缓存上一次的计算结果：123456789// 计算阶乘，并将结果缓存至函数的属性中function factorial(n) &#123; if (isFinite(n) &amp;&amp; n&gt;0 &amp;&amp; n==Math.round(n)) &#123; if (!(n in factorial)) factorial[n] = n*factorial(n-1); return factorial[n]; &#125; else return NaN; // 如果输入有误&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript数组方法列表","slug":"Javascript数组方法列表","date":"2017-10-05T17:26:25.000Z","updated":"2017-10-06T15:00:38.737Z","comments":true,"path":"2017/10/06/Javascript数组方法列表/","link":"","permalink":"/2017/10/06/Javascript数组方法列表/","excerpt":"ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，ECMAScript 5新新增了一些新的数组遍历方法。","text":"ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，ECMAScript 5新新增了一些新的数组遍历方法。 ECMAScript 3 a.join()合并数组元素转换为字符串 a.reverse()反转数组 a.sort()排列数组元素 a.concat()合并多个数组 a.slice()截取数组元素并返回新数组 a.splice()数组操作万能方法 push()和pop()插入/删除最后一个元素 unshift和shift()插入/删除最后一个元素 toString()和toLocaleString()Array.sort()Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序： 如果数组包含undefined元素，它们会被排列到数组的尾部。 为了按照其他方式而非字母表顺序进行组排序，必须给sort()方法传递一个比较函数。 假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数组。并且，假设两个值相等，函数应该返回0.123456var a = [33, 4 ,1111, 222];a.sort(); // 字母表顺序：1111,222,33,4a.sort(function(a,b) &#123; // 数值顺序： 4，33，222，1111 return a-b;&#125;);a.sort(function(a,b) &#123; return b-a&#125;); //数值大小相反的顺序 Array.concat()Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。123456var a = [1,2,3];a.concat(4,5); // [1,2,3,4,5]a.concat([4,5]); // [1,2,3,4,5]a.concat([4,5],[6,7]); // [1,2,3,4,5,6,7]a.concat(4,[5,[6,7]]); // [1,2,3,4,5,[6,7]]a // [1,2,3]:a没有改变 Array.slice()12345var a = [1,2,3,4,5];a.slice(0,3); // [1,2,3]a.slice(3); // [4,5]a.sliec(1.-1); // [2,3,4]a.slice(-3,-2); // [3] Array.splice()不同于slice()和concat()，splice()会修改调用的数组。 如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。12345678var a =[1,2,3,4,5,6,7,8];a.splice(4); // 返回[5,6,7,8];a是[1,2,3,4]a.splice(1,2); // 返回[2,3];a是[1,4]a.splice(1,1); // 返回[4];a是[1]var a = [1,2,3,4,5];a.splice(2,0,'a','b'); // 返回[];a是[1,2,'a','b',3,4,5]a.splice(2,2,[1,2],3); // 返回['a','b'];a是[1,2,[1,2],3,3,4,5] ECMAScript 5ECMAScript 5中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。 forEach()从头到尾遍历数组。 map()将每个元素传递给函数，并返回一个数组 filter()过滤函数，返回一个被过滤的数组 every()和some()用来判断数组属性的方法 reduce()和reduceRight()迭代函数 indexOf()和lastIndexOf()搜索函数 Array.forEach()这个函数可以修改原始数组。123456789var data = [1,2,3,4,5]; // 要求和的数组// 计算数组元素的和值var sum = 0; // 初始化为0data.forEach(function(value) &#123; sum += value; &#125;); // 将每个值累加在sum上sum; // =&gt; 15//每个数组元素自加1data.forEach(function(v,i,a) &#123;a[i]=v+1&#125;);data // =&gt; [2,3,4,5,6] 这个方法的遍历如需终止，需要将方法放在try块中。（犀牛书p156） Array.map()12a = [1,2,3];b = a.map(function(x) &#123;return x*x; &#125;); // b是[1,4,9] Array.filter()函数的返回值如果是true或者是能转换为true值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。例如：123a = [5,4,3,2,1];smallvalues = a.filter(function(x) &#123;return x&lt;3&#125;); // [2,1]everyother = a.filter(function(x,i) &#123;return i&amp;2==0&#125;); // [5,3,1] Array.every()和Array.some()every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。123a = [1,2,3,4,5];a.every(function(x) &#123; return x &lt; 10; &#125;); // true:所有的值&lt;10a.every(function(x) &#123; return x * 2 === 0;&#125;); // fasle:不是所有的值都是偶数 123a = [1,2,3,4,5];a.some(function(x) &#123;return x%2===0;&#125;); // truea.some(isNaN); // false reduce()和reduceRight()reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。12var a=[1,2,3,4,5];var sum = a.reduce(function(x,y) &#123;return x+y &#125;, 0); 这里的x可以看作是迭代的值，y是元素，第二个参数0是x的初始值。 reduceRight()工作原理和reduce()一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。 indexOf()和lastIndexOf()indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf()从头到尾搜索，而’lastIndexOf()’则反向搜索。1234a = [0,1,2,1,0];a.indexOf(1); // =&gt; 1: a[1]是1a.lastIndexOf(1); // =&gt; 3: a[3]是1a.indexOf(3); // =&gt; -1: 没有值为3的元素 indexOf()和lastIndexOf()可以提供第二个参数，指定从那个索引开始搜索。利用第二个参数可以搜索全部的值的索引。1pos = a.indexOf(x, pos);","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js数组","slug":"js数组","permalink":"/tags/js数组/"}]},{"title":"Javascript对象（七）——对象的三个属性","slug":"Javascript对象（七）——对象的三个属性","date":"2017-10-05T15:45:21.000Z","updated":"2017-10-05T16:42:04.071Z","comments":true,"path":"2017/10/05/Javascript对象（七）——对象的三个属性/","link":"","permalink":"/2017/10/05/Javascript对象（七）——对象的三个属性/","excerpt":"对象的三个属性：原型属性、类属性、可扩展性。","text":"对象的三个属性：原型属性、类属性、可扩展性。 原型属性获取原型对象：1Object.prototype 查询原型：1Object.getPrototypeOf() 查询构造函数：1o.constructor 检测是否是某对象原型：1234var p = &#123;x:1&#125;;var o = Object.create(p);p.isPrototypeOf(o); =&gt; trueObject.prototype.isPrototypeOf(o); =&gt; true 类属性对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3和ECMAScript 5都未提供设置这个属性的方法，并和自由一种间接的方法可以查询它。默认的toString()方法返回了如下这种格式的字符串：1[object class] 因此可以编写classOf函数：12345function classof(o) &#123; if (o===null) return \"Null\"; if (o===undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 由于很多对象的toString()方法重写了，所以利用call()调用最原始的toString()函数。 下面是这个函数执行的例子：1234567891011classof(null) // =&gt; \"Null\"classof(1) // =&gt; \"Number\"classof(\"\") // =&gt; \"String\"classof(false) // =&gt; \"Boolean\"classof(&#123;&#125;) // =&gt; \"Object\"classof([]) // =&gt; \"Array\"classof(/./) // =&gt; \"RegExp\"classof(new Date()) // =&gt; \"Date\"classof(window) // =&gt; \"Window\"(这是客户端宿主对象)function f() &#123;&#125;; // 定义一个自定义构造函数classof(new f()) // =&gt; \"Object\" 可扩展性对象的扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由Javascript引擎定义的。 Object.preventExtensions()通过将对象传入Object.preventExtensions()，将对象转换为不可扩展的。 注意，一旦将对象转换为不可扩展的，就无法将其转换回可扩展的了。 同样需要注意的是，preventExtensions()只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。 判断函数Object.isExtensions() Object.seal()Object.seal()和Object.preventExtensions()类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。 判断函数Object.isSealed() Object.freeze()Object.freeze()将更严格地锁定对象——“冻结”（frozen）。除了对象设置为不可扩展的和将其属性设置为不可配置之外，还可以将它自由的所有数据属性设置为只读。 判断函数Object.isFrozen()","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（六）——对象的特性","slug":"Javascript对象（六）——对象的特性","date":"2017-10-05T13:10:28.000Z","updated":"2017-10-05T13:47:55.908Z","comments":true,"path":"2017/10/05/Javascript对象（六）——对象的特性/","link":"","permalink":"/2017/10/05/Javascript对象（六）——对象的特性/","excerpt":"对象的属性除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在ECMAScript 3中无法设置这些特效。而ECMAScript 5中查询和设置这些属性特性的API。这些API对于库开发者来说非常重要。","text":"对象的属性除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在ECMAScript 3中无法设置这些特效。而ECMAScript 5中查询和设置这些属性特性的API。这些API对于库开发者来说非常重要。 数据属性的4个特性 值(value) 可写性(writable) 可枚举性(enumerable) 可配置性(configurable) 存取器属性的4个特性 读取(get) 写入(set) 可枚举性 可配置性 Object.getOwnPropertyDescriptor()通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符：12345678910// 返回 &#123;value: 1,writable: true,enumerable: true,configurable: true&#125;Object.getOwnPropertyDescriptor(&#123;x:1&#125;, \"x\");// 查询上下文中定义的random对象的octet属性（这里没有random对象）// 返回 &#123; get: /*func*/, set:undefined, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(random, \"octet\");// 对于继承属性和不存在的属性，返回undefinedObject.getOwnPropertyDescriptor(&#123;&#125;, \"x\"); // undefined,没有这个属性Object.getOwnPropertyDescriptor(&#123;&#125;, \"toString\"); // undefined,继承属性 从函数名字就可以看出，Object.getOwnPropertyDescriptor()只能得到自有属性的描述符。 Object.defineProperty()要想设置属性的特性，或者想让新建属性具有某种特效，则需要调用Object.defineProperty()，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象：12345678910111213141516171819202122232425var o = &#123;&#125;; // 创建一个空对象// 添加一个不可枚举的属性x，并赋值为1Object.defineProperty(o, \"x\", &#123; value: 1, writable: true, enumerable: false, configurable: true&#125;);// 属性是存在的，但不可枚举o.x; // =&gt; 1Object.keys(o) // =&gt; []// 现在对属性x做修改，让它变为只读Object.defineProperty(o, \"x\", &#123;writable: false &#125;);// 试图更改这个属性的值o.x = 2; // 操作失败但不报错，而在严格模式中抛出类型错误异常o.x // =&gt; 1// 属性依然是可配置的，因此可以通过这种方式对它进行修改：Object.defineProperty(o, \"x\", &#123;value: 2&#125;);o.x // =&gt; 2//现在将x从数据属性修改为存取器属性Object.defineProperty(o, \"x\", &#123; get: function() &#123;return 0; &#125;&#125;);o.x // =&gt; 0 传入Object.defineProperty()属性描述符对象不必包含所有4个特效。对于新创建的属性来说，默认的特性值是false或undefined。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。 Object.defineProperties()如果要同时修改或创建多个属性，则需要使用Object.defineProperties()。123456789var p = Object.defineProperties(&#123;&#125;,&#123; x: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;, y: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;, r: &#123; get: function() &#123;return Math.sqrt(this.x*this.x + this.y*this.y) &#125;, enumerable: true, configurable: true &#125;&#125;); 这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终Object.defineProperties()返回修改后的对象（和Object.defineProperty一样）。 配置规则 如果对象是不可扩展，则可以编辑已有的自有属性，但不能给它添加新属性。 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。 如果存取器属性是不可配置的，则不能修改其getter和setter方法，也不能将它转换为数据属性。 如果数据属性是不可配置的，则不能将它转换为存取器属性。 如果数据属性是不可配置的，则不能将它的可写性从false修改为true，但可以从true修改为false。 如果数据属性是不可配置且不可泄的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（五）——存取器属性","slug":"Javascript对象（五）——存取器属性","date":"2017-10-05T11:34:06.000Z","updated":"2017-10-05T15:07:49.289Z","comments":true,"path":"2017/10/05/Javascript对象（五）——存取器属性/","link":"","permalink":"/2017/10/05/Javascript对象（五）——存取器属性/","excerpt":"由getter和setter定义的属性称作“存取器属性”（accessor property），它不用于“数据属性”（data property），数据属性只有一个简单的值。","text":"由getter和setter定义的属性称作“存取器属性”（accessor property），它不用于“数据属性”（data property），数据属性只有一个简单的值。 在ECMAScript 5（包括除了IE之外的最新主流浏览器的ECMAScript 3的实现）中,属性值可以用一个或两个方法替代，这两个方法就是getter和setter。 和数据属性不同，存取器属性不具有可写性。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回undefined。 定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */&#125;,set accessor_prop(value) &#123; /*这里是函数体*/&#125;&#125; 注意：存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用function关键字，而是使用get和（或）set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数提的结束和下一个方法或数据属性之间有逗号分隔。 在ECMAScript 5中，可以通过Object.getOwnPropertyDescriptor()和Object.defineProperty()来修改getter和setter方法。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（四）——检测属性","slug":"Javascript对象（四）——检测属性","date":"2017-10-05T10:22:26.000Z","updated":"2017-10-05T11:34:20.270Z","comments":true,"path":"2017/10/05/Javascript对象（四）——检测属性/","link":"","permalink":"/2017/10/05/Javascript对象（四）——检测属性/","excerpt":"in运算符、hasOwnProperty()方法和propertyIsEnumerable()方法。顺便介绍另外两个偏门的枚举属性的方法：Object.keys()和Object.getOwnPropertyNames()。","text":"in运算符、hasOwnProperty()方法和propertyIsEnumerable()方法。顺便介绍另外两个偏门的枚举属性的方法：Object.keys()和Object.getOwnPropertyNames()。 in运算符in运算符的左侧是属性名（字符串），右侧是对象。如果对象的自由属性或继承属性中包含这个属性则返回true。1234var o = &#123; x:1 &#125;;\"x\" in o; // true: \"x\"是o的属性\"y\" in o; // false: \"y\"不是o的属性\"toString\" in o; // true: o继承toString属性 出来使用in运算符之外，另一种更简便的方法是使用“!==”判断一个属性是否是undefined：1234var o = &#123; x: 1 &#125;; o.x !== undefined; // trueo.y !== undefined; // falseo.toString !== undefined; // true 然而有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为undefined的属性。例如下面的代码：1234567var o = &#123; x: undefined &#125;; //属性被显式赋值为undefinedo.x !== undefined; // falseo.y !== undefined; // false\"x\" in o; // true\"y\" in o; // falsedelete o.x; // 删除了属性x\"x\" in o; // false hasOwnProperty()方法对象的hasOwnProperty()方法是用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false:1234var o = &#123; x: 1 &#125;;o.hasOwnProperty(\"x\"); // true: o有一个自有属性xo.hasOwnProperty(\"y\"); // false: o中不存在属性yo.hasOwnProperty(\"toString\"); // false: toString是继承属性 propertyIsEnumerable()方法propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性的可枚举性为true时它才返回true。12345var o = inherit(&#123; y:2 &#125;);o.x = 1;o.propertyIsEnumerable(\"x\"); // true: o有一个可枚举的自有属性xo.propertyIsEnumerable(\"y\"); // false: y是继承过来的Object.prototype.propertyIsEnumerable(\"toString\"); // false: 不可枚举 开个玩笑看下面代码：12Object.prototype.hasOwnProperty(\"has.OwnProperty\"); // =&gt; trueObject.prototype.hasOwnProperty(\"propertyIsEnumerable\"); // =&gt; true Object.keys()ECMAScript 5定义了两个用以枚举属性名称的函数。 第一个是Object.keys(),这个函数返回一个数组，这个数组由对象中可枚举的自由属性的名称组成。 Object.getOwnPropertyNames()这个函数返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（三）——删除属性delete","slug":"Javascript对象（三）——删除属性delete","date":"2017-10-05T09:52:08.000Z","updated":"2017-10-05T10:13:18.998Z","comments":true,"path":"2017/10/05/Javascript对象（三）——删除属性delete/","link":"","permalink":"/2017/10/05/Javascript对象（三）——删除属性delete/","excerpt":"delete的机制，要注意的地方。","text":"delete的机制，要注意的地方。 delete用法delete运算符可以删除对象的属性。它的操作数应该是一个可以访问表达式。12delete book.author; // book不再有属性authordelete book[\"main title\"]; // book也不再有属性\"main title\" 只是断开联系然而令人意外的是，**delete只是断开属性和宿主对象的联系，并不会去操作属性中的属性。 来看下面例子：12345a = &#123;p:&#123;x:1&#125;&#125;; // 创建一个词典b = a.p; // 将b指针指向pdelete a.p; // 删除a中的对象pb.x; // =&gt; 1:表面p依然存在 从上面的例子可以看到，由于已经删除的属性引用依然存在，因此在Javascript的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除（关于如何遍历删除，我也不是很理解）。 只能操作自由属性delete运算符只能删除自由属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。 严格模式限制在严格模式中，delete后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性：12delete x; // 在严格模式下报语法错误delete this.x; // 正常工作","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（二）——三种创建方法","slug":"Javascript对象（二）——三种创建方法","date":"2017-10-04T17:03:45.000Z","updated":"2017-10-04T17:34:21.676Z","comments":true,"path":"2017/10/05/Javascript对象（二）——三种创建方法/","link":"","permalink":"/2017/10/05/Javascript对象（二）——三种创建方法/","excerpt":"对象直接量、new创建对象、还有Object.create()方法创建对象。","text":"对象直接量、new创建对象、还有Object.create()方法创建对象。 对象直接量创建对象最简单的方式就是Javascript代码中使用对象直接量。1var empty = &#123;&#125;; 通过new创建对象1var o = new Object(); // 创建一个空对象，和&#123;&#125;一样 Object.create()这个方法恐怕在开发JS库的时候才会用上。 ECMAScript 5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Objcet.create()提供第二个可选参数，用以对对象的属性进行进一步描述。1var o1 = Object.create(&#123;x:1, y:2&#125;); //o1继承了属性x和y 可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如toString()，也就是说，它将不能和“+”运算符一起正常工作：1var o2 = Object.create(null); // o2不继承任何属性和方法 如果想要创建一个普通的空对象（比如通过{}或new Object()创建的对象），需要传入Object.prototype：1var o3 = Object.create(Object.prototype); // o3和&#123;&#125;和new Object()一样","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（一）——基本术语","slug":"Javascript对象（一）——基本术语","date":"2017-10-04T17:03:03.000Z","updated":"2017-10-04T17:22:16.566Z","comments":true,"path":"2017/10/05/Javascript对象（一）——基本术语/","link":"","permalink":"/2017/10/05/Javascript对象（一）——基本术语/","excerpt":"对象基本知识，方便看文章时候的理解。","text":"对象基本知识，方便看文章时候的理解。 我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散射（hash）”、“散列表（hashtable）”、“字典（dictionary）”、“关联数组（associative）”。 然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，Javascript对象还可以从一个成为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承（prototypal inheritance）”是Javascript的核心特征。 属性特性 可写（writable attribute），表明是否可以设置该属性的值。 可枚举（enumerable attribute），表明是否可以通过for/in循环返回该属性。 可配置（configurable attribute），表明是否可以删除或修改该属性。 在ECMAScript 5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。 对象特性 对象的原型（prototype）指向另一个对象，本对象的属性继承自它的原型对象。 对象的类（class）是一个标识对象类型的字符串。 对象的扩展标记（extensible flag）指明（在ECMAScript 5中）是否可以向该对象添加新属性。 三类JS对象+两类属性 内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。 宿主对象（host object）是由Javascript解析器所嵌入的宿主环境（比如Web浏览器）定义的。客户端Javascript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的Javascript函数对象，那么宿主对象也可以当成内置对象。 自定义对象（user-defined object）是由运行中的Javascript代码创建的对象。 自有属性（own property）是直接在对象中定义的属性。 继承属性（inherited property）是在对象的原型对象中定义的属性。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript严格模式","slug":"Javascript严格模式","date":"2017-10-04T16:15:12.000Z","updated":"2017-10-04T16:25:25.754Z","comments":true,"path":"2017/10/05/Javascript严格模式/","link":"","permalink":"/2017/10/05/Javascript严格模式/","excerpt":"严格模式修复了JS中的重要缺陷，并提供健壮的差错功能和增强的安全机制。但由于一般不会特别去声明是strict模式，用得比较少，在这里只是做个简介，如果有需要的话，再在本文扩充。","text":"严格模式修复了JS中的重要缺陷，并提供健壮的差错功能和增强的安全机制。但由于一般不会特别去声明是strict模式，用得比较少，在这里只是做个简介，如果有需要的话，再在本文扩充。 “use strict”是ECMAScript 5引入的一条指令。指令不是语句（但非常接近语句）。 使用“use strict”指令的目的是说明（脚本或者函数中）后续的代码将会解析为严格代码（strict code）。 对于那些不支持strict模式的浏览器，“use strict”只是一条没有副作用的表达式语句而已，它什么都不做。 严格模式和非严格模式之间的区别主要是以下三点： 在严格模式中禁止使用with语句。 在严格模式中，所有变量都要声明。如果给一个未声明的变量、函数、函数参数、catch从句参数（这两个我需要实例验证一下）或者全局对象的属性赋值，将会抛出一个引用错误异常。 在严格膜使用，调用函数（不是方法）中的this值是undefined。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特性来判断Javascript实现是否支持严格模式：1var hasStrictMode = (function() &#123; \"use strict\";return this === undefined &#125;())","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中debugger语句","slug":"Javascript中debugger语句","date":"2017-10-04T15:49:12.000Z","updated":"2017-10-04T15:58:03.128Z","comments":true,"path":"2017/10/04/Javascript中debugger语句/","link":"","permalink":"/2017/10/04/Javascript中debugger语句/","excerpt":"debugger语句是实战中是为了方便调试用的，但是就我开发体验来说，使用debugger语句的可能性不大。","text":"debugger语句是实战中是为了方便调试用的，但是就我开发体验来说，使用debugger语句的可能性不大。 debugger语句通常什么都不做。然而，当调试程序可用并运行的时候，Javascript解析器将会（非必须）以调试模式运行。 下面是使用的实例：1234function f(o) &#123; if (o === undefined) debugger; // 这一行代码只是用于临时测试 ... // 函数的其他部分&#125; 在chrome中测试以上代码：1f(); // 不输入参数值，触发debugger行为 这时候chrome会进入调试模式，并且指出调试语句。 在ECMAScript 5中,debugger语句正式加入到这门语言里。但在相当长的一段时间里，主流浏览器厂商已经将其实现了。注意，可用的调试器是远远不够的，debugger语句不会启动调试器。但如果调试器已经在运行中，这条语句才会真正产生一个断点。例如，如果使用Firefox的调试扩展插件Firebug，则并必须首先为待测试的网页启用Friebug，这样debugger语句才能正常工作。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中的with语句","slug":"Javascript中的with语句","date":"2017-10-04T15:20:52.000Z","updated":"2017-10-04T15:40:27.139Z","comments":true,"path":"2017/10/04/Javascript中的with语句/","link":"","permalink":"/2017/10/04/Javascript中的with语句/","excerpt":"在实战中使用with语句，要注意几点。","text":"在实战中使用with语句，要注意几点。 with语句with语句用于临时扩展作用域链，它具有以下的语法：12with (object)statement 这条语句将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态。 with不效率在严格模式中是严格使用with语句的，并且在非严格模式里也是不推荐使用with语句的，尽可能避免使用with语句。 那些使用with语句的Javascript代码非常难于优化，并且同没有使用with语句的代码相比，它运行更慢。 对于对象嵌套层次很深的情况，使用with语句是可以简化代码编写，比如我们要访问HTML表单元素，我们可以这么做：123456with(document.forms[0]) &#123; // 直接访问表单元素，例如： name.value = \"\"; address.value = \"\"; email.value = \"\";&#125; with小括号后面的对象会临时挂载在作用域链上，这样减少了大量的输入。 有时候为了便于优化代码或者提高性能，我们会使用替代的方法：1234var f = document.forms[0];f.name.value = \"\";f.address.value = \"\";f.email.value = \"\"; with不能创建新属性犀牛书上有一个例子：1with(0) x = 1; 书上的分析是这样的： 如果对象o有一个属性x，那么这行代码给这个属性赋值为1。但如果o中没有定义属性x，这段代码和不使用with语句的代码x=1是一模一样的。它给一个局部变量或者全局变量赋值，或者创建全局对象的一个新属性。with语句提供了一种读取o的属性的快捷方式，但它并不能创建o的属性。 为了便于理解，我在chrome浏览器的console中测试了以下例子：1234var o = &#123;&#125;; // 定义一个新的空对象with(o) x = 1; // =&gt; 1:赋值成功console.log(o.x); // =&gt; undefined：未定义console.log(x); // =&gt; 1：数据绑定在全局对象中 根据这个例子再细读一次犀牛书的原话，应该有所收获。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中for/in循环机理","slug":"Javascript中for-in循环机理","date":"2017-10-03T13:12:36.000Z","updated":"2017-10-03T16:30:41.160Z","comments":true,"path":"2017/10/03/Javascript中for-in循环机理/","link":"","permalink":"/2017/10/03/Javascript中for-in循环机理/","excerpt":"for/in循环是非常有用的原生语句，了解for/in循环的作用机理，可以实现意想不到的效果。","text":"for/in循环是非常有用的原生语句，了解for/in循环的作用机理，可以实现意想不到的效果。 基本语法for/in语句也使用了for关键字，但它是和常规的for循环完全不同的一类循环。for/in循环语句的语法如下：12for (variable in object) statement for/in循环是用来方便地遍历对象的属性成员。下面是for/in的一个实例：123for(var p in o) &#123; console.log(o[p]);&#125; 在执行for/in语句的过程中，Javascript解析器首先计算Object表达式。如果表达式为null或者undefined，Javascript解析器将会跳过循环并执行后续的代码。 作用机理只要for/in循环中variable的值可以当作赋值表达式的左值，它可以是任意表达式。**每次循环都会计算这个表达式，也就是说每次循环它计算的值都有可能不同。例如，可以使用下面这段代码将所有对象属性复制至一个数组中：123var o = &#123; x:1,y:2,z:3&#125;;var a = [],i = 0;for (a[i++] in o) /* empty */ ; 分析：上面的for/in循环中，每一次循环都会将i加一，最关键的是，循环体object中的属性值会赋值给variable，所以每一次循环就会将object对应的值复制到数组a中去。 循环遍历for/in循环并不会遍历对象的所有属性，只有“可枚举（enumerable）”的属性才会被遍历到。 在ECMAScript 5中可以通过特殊的手段让可枚举属性变为不可枚举的。 如果for/in的循环体删除了还未枚举的属性，那么这个属性将不会被枚举到。 如果循环体定义了对象的新属性，这些属性通常也不会被枚举到（然而,Javascript的有些实现是枚举这些在循环体内增加的继承属性）。 关于属性枚举的顺序，我也不是特别了解。在这里就不深入讨论了。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript函数声明与函数定义表达式","slug":"Javascript函数声明与函数定义表达式","date":"2017-10-03T12:03:27.000Z","updated":"2017-10-03T12:19:54.562Z","comments":true,"path":"2017/10/03/Javascript函数声明与函数定义表达式/","link":"","permalink":"/2017/10/03/Javascript函数声明与函数定义表达式/","excerpt":"一直对JS的函数声明和函数定义表达式不太清楚，今天来明确一下定义以及各自的区别。","text":"一直对JS的函数声明和函数定义表达式不太清楚，今天来明确一下定义以及各自的区别。 what?关键字function用来定义函数。 函数声明1function f(x) &#123; return x+1; &#125; 函数定义表达式1var f = function(x) &#123; return x+1; &#125; difference尽管函数声明语句和函数表达式包含相同的函数名，但二者仍然不同。 函数声明语句中函数名是一个变量名，变量指向函数对象。和通过var声明变量一样，函数定义语句中函数被显示地“提前”到了额脚本或函数的顶部。因此它们在整个脚本和函数内都是可见的。 使用var的话，只有变量声明提前了——变量初始化代码仍然在原来的位置。 然而使用函数声明语句的话，函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明。也就是说，可以在声明一个JavaSript函数前调用它。 和var语句一样，函数声明语句创建的变量也是无法删除的。 attention函数定义不能出现在if语句、while循环或其他任何语句中。 正因为有这种限制，函数声明没有被ES 5归纳为语句。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中delete运算符","slug":"Javascript中delete运算符","date":"2017-10-03T11:17:01.000Z","updated":"2017-10-03T11:40:08.786Z","comments":true,"path":"2017/10/03/Javascript中delete运算符/","link":"","permalink":"/2017/10/03/Javascript中delete运算符/","excerpt":"delete是一元操作符，它用来删除对象属性或者数组属性。就像赋值、递增运算符一样，delete也具有副作用，它是用来做删除操作的，不是用来返回一个值。关于delete需要注意一下几点：","text":"delete是一元操作符，它用来删除对象属性或者数组属性。就像赋值、递增运算符一样，delete也具有副作用，它是用来做删除操作的，不是用来返回一个值。关于delete需要注意一下几点： 直接删除属性先看下面例子：1234var a = [1,2,3]; //定义一个数组delete a[2]; // 删除最后一个数组元素2 in a; // =&gt; false: 元素2在数组中已经不存在了a.length; // 3: 没有改变 大家都知道，Array是Object的一个子类，本质上是对象。在删除数组的属性时，行为跟作用与对象无二。 从上面的例子可以发现，删除属性或者删除数组元素不仅仅是设置了一个undefined的值。当删除一个属性的时候，这个属性将不再存在了。读取一个不存在的属性将返回undefined，但是可以通过in运算符，来检测这个属性是否在对象中存在。 某些属性不能删除并不是所有的属性都可以删除，一些内置核心的客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也是不能删除的。 在ECMAScript 5严格模式中，如果delete是非法的，则会返回语法错误SyntaxError。 在非严格模式中，非法错误将返回false值。 这里有些关于delete运算符的例子：1234567891011var o = &#123; x:1, y=2 &#125;; // 定义一个变量，初始化对象delete o.x; // =&gt; true: 删除成功typeof o.x; // =&gt; \"undefined\"delete o.x; // =&gt; 删除不存在属性，返回\"true\"delete o; // 不能删除通过var声明的变量，返回false // 在严格模式下会抛出异常delete 1; // 参数不是一个左值，返回truethis.x = 1; // 全局定义一个属性，没有用vardelete x; // 试图删除它，在非严格模式下返回true // 在严格模式下会抛出异常，可以用\"delete this.x\"代替x; // 运行错误，没有定义x 关于上面例子，有一点在我看到这个例子的时候特别困惑：this.x并没有用var定义，但为什么在严格模式下执行delete操作会抛出异常呢？按照正常情况下是能够被删除。请注意，严格模式规定变量都需要使用var操作符定义，所以不存在不用var定义这一做法。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中eval()函数详解","slug":"Javascript中eval-函数详解","date":"2017-10-03T06:33:34.000Z","updated":"2017-10-03T07:15:54.578Z","comments":true,"path":"2017/10/03/Javascript中eval-函数详解/","link":"","permalink":"/2017/10/03/Javascript中eval-函数详解/","excerpt":"eval()是一个函数，但它已经被当成是运算符来对待了。如果一个函数调用了eval()，那么解析器将无法对这个函数进行优化。eval()函数可以用来使用制作在线的Javascript解析器，或者是作手动的函数优化。","text":"eval()是一个函数，但它已经被当成是运算符来对待了。如果一个函数调用了eval()，那么解析器将无法对这个函数进行优化。eval()函数可以用来使用制作在线的Javascript解析器，或者是作手动的函数优化。 eval()eval()只有一个参数。如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成Javascipt代码进行编译。 关于eval()最重要的是，它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。 如果在最顶层代码中调用eval()，当然，它会作用于全局变量和全局函数。 全局eval()ECMAScript 3标准规定了任何解析器都不允许对eval()赋予别名。如果eval()函数通过别名调用的话，则会抛出一个EvalError异常。 事实上，大多数的实现并不是这么做的。 当通过别名调用的时候，eval()会将其字符串当成顶层的全局代码来执行。执行的代码可能会定义新的全局变量和全局函数。 ECMAScript 5是反对使用EvalError的，并且规范了eval()的行为。“直接的eval”，当直接使用非限定的“eval”名称（eval看起来像是一个保留字）来调用eval()函数时，通常成为“直接eval”。直接调用eval()时，它总是在调用它的上下文作用域内执行。其他的间接调用则会使用全局对象作为其上下文的作用域，并且无法读、写、定义局部变量和函数。 ——摘录自《Javascript权威指南》 上面这段话很长，但是我们可以用简洁的语言归纳：ES 5在打ES 3的脸，浏览器对ES 3的抗议获得大成功，ES 5将大部分浏览器对eval()的实现纳入了标准。 下面有一段示例代码：1234567891011121314var geval = eval; // 使用别名调用eval将会是全局evalvar x = \"global\",y = \"global\"; // 两个全局变量function f() &#123; // 函数内执行的是局部eval var x = \"local\"; // 定义局部变量 eval(\"x += 'changed';\"); // 直接eval更改了局部变量和值 return x; // 返回更改后的局部变量&#125; function g() &#123; // 这个函数内执行了全局eval var y = \"local\"; // 定义局部变量 geval(\"y += 'changed';\"); // 间接调用改变了全局变量的值 return y; // 返回未更改的局部变量&#125;console.log(f(), x); // \"localchanged global\"console.log(g(), y); // \"local globalchanged\" 严格eval()ECMAScript 5严格模式对eval()施加更多的限制。 严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。 此外，严格模式将”eval”列为保留字，这让eval()更像一个运算符。不能用一个别名覆盖eval()函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为”eval”。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript带操作的赋值运算——小坑","slug":"Javascript带操作的赋值运算——小坑","date":"2017-10-01T13:46:49.000Z","updated":"2017-10-01T14:12:13.601Z","comments":true,"path":"2017/10/01/Javascript带操作的赋值运算——小坑/","link":"","permalink":"/2017/10/01/Javascript带操作的赋值运算——小坑/","excerpt":"所谓“带操作的赋值运算”，就是带“op =”的赋值运算，比如*=。在一般情况下，这种表达式会有几乎等价的语句。但在特殊情况下，它们又是有区别的。","text":"所谓“带操作的赋值运算”，就是带“op =”的赋值运算，比如*=。在一般情况下，这种表达式会有几乎等价的语句。但在特殊情况下，它们又是有区别的。 带操作的赋值运算有很多，如+=、-=、*=、/=、%=等，还有跟二进制运算有关的运算符，我这里就不一一列举出来了。 大多数情况下，表达式为1a op = b 这里op代表一个运算符，这个表达式如下面的表达式等价：1a=a op b 在第一行中，表达式a只计算了一次，在第二行中，表达式a计算了两次。只有a包含具有副作用的表达式的时候，两者才不等价。比如，下面两个表达式就是不等价的：12data[i++] *= 2data[i++] = data[i++] * 2 可能不太容易看懂，我们举个实例12345678910111213// 例一var data = [1,3,5]; // 定义一个数组var i = 0;data[i++] *= 2;console.log(data); // =&gt; [2,3,5]console.log(i); // =&gt; 1：计算了一次// 例二var data = [1,3,5]; // 初始化数组var i = 0;data[i++] = data[i++] * 2console.log(data); // =&gt; [6,3,5]console.log(i); // =&gt; 2:计算了两次 分析： 例一中，表达式将左侧的i++放在了最后，首先计算了data[0]*2的值，得到2，再将2赋值给了data[0]，最后才运算i++； 例二中，表达式首先计算了右侧的i++，所以右侧的值为data[1]*2即6。然后将右侧的值赋值给data[1]，最后再执行一次左侧的i++。 可以说，这种带副作用的运算十分复杂和混乱，建议实际上不要将带副作用的左值放在左侧。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript逻辑运算符——原理详解","slug":"Javascript逻辑运算符——原理详解","date":"2017-09-30T16:38:48.000Z","updated":"2017-09-30T16:54:57.785Z","comments":true,"path":"2017/10/01/Javascript逻辑运算符——原理详解/","link":"","permalink":"/2017/10/01/Javascript逻辑运算符——原理详解/","excerpt":"最开始我看廖学锋的javascript教程，以为&amp;&amp;是直接返回一个布尔值ture或者false，直到我膝盖中了一剪，遇到犀牛书，突然恍然大悟。","text":"最开始我看廖学锋的javascript教程，以为&amp;&amp;是直接返回一个布尔值ture或者false，直到我膝盖中了一剪，遇到犀牛书，突然恍然大悟。 逻辑与（&amp;&amp;）犀牛书中描述了&amp;&amp;的第三层理解： 运算符首先计算左操作数的值，即首先计算“&amp;&amp;”左侧的表达式。如果计算结果是加值，那么整个表达式的结果一定是假值，因此“&amp;&amp;”这时简单地返回左操作数，并不会对右操作数进行计算。 反过来讲，如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。 假值是false、null、undefined、0、-0、NaN和&quot;&quot; 1234var o = &#123; x:1 &#125;;var p = null;o &amp;&amp; o.x // =&gt;1:0 是真值，因此返回值为o.xp &amp;&amp; p.x // =&gt;null: p是假值，因此将其返回，并不去计算p.x 逻辑或（||）尽管“||”运算大多情况下只是做简单布尔或（OR）运算，和“&amp;&amp;”一样，它也具有一些更复杂的行为。 它会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的计算结果。 1234// 如果max_width已经定义了，直接使用它// 否则在preferences对象中查找max_width// 如果没有定义它，则使用一个写死的常量var max = max_width || preferences.max_width || 500; 逻辑非（!）“!”运算符首先将其操作数转换为布尔值，然后再对布尔值求反。 也就是说“!”总是返回true或者false。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中instanceof运算符","slug":"Javascript中instanceof运算符","date":"2017-09-30T16:11:22.000Z","updated":"2017-09-30T16:21:54.747Z","comments":true,"path":"2017/10/01/Javascript中instanceof运算符/","link":"","permalink":"/2017/10/01/Javascript中instanceof运算符/","excerpt":"了解javascript中instanceof运算符原理，有利于在实际开发中更好地使用这个运算符。","text":"了解javascript中instanceof运算符原理，有利于在实际开发中更好地使用这个运算符。 instanceof运算符实例instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true；否则返回false。123456789var d = new Date(); // 创建一个Date对象d instanceof Date; // =&gt; trued instanceof Object; // =&gt; falsed instanceof Number; // =&gt; falsevar a = [1,2,3];a instanceof Array; // =&gt; truea instanceof Object; // =&gt; truea instanceof RegExp; // =&gt; false instanceof运算符原理为了理解instanceof运算符是如何工作的，必须首先理解“原型链”。为了计算表达式o instanceof f，Javascript首先计算f.prototype，然后在原型链中查找o，如果找到，返回true，否则为false。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript二进制浮点数和四舍五入错误","slug":"Javascript二进制浮点数和四舍五入错误","date":"2017-09-30T15:11:24.000Z","updated":"2017-09-30T15:28:12.961Z","comments":true,"path":"2017/09/30/Javascript二进制浮点数和四舍五入错误/","link":"","permalink":"/2017/09/30/Javascript二进制浮点数和四舍五入错误/","excerpt":"Javascript的浮点数采用的是二进制表示法，虽然不清楚具体的算法，但知道这种表示法会造成浮点数的误差。如果网站要进行高精度的计算，涉及经融或大计算领域，尽可能使用整数运算。","text":"Javascript的浮点数采用的是二进制表示法，虽然不清楚具体的算法，但知道这种表示法会造成浮点数的误差。如果网站要进行高精度的计算，涉及经融或大计算领域，尽可能使用整数运算。 实数有无数多个，但Javascript通过浮点数形式只能表示其中的有限个数（确切地说是18 437 736 874 454 810 627个）。也就是说，当在Javascript中使用实数的时候，常常只是真实值的一个近似表示。 Javascript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如,1/2、1/8和1/1024。遗憾的是，我们常用的分数都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字。 **Javascript中数字具有足够的精度，并可以极其近似于0.1.但事实上，数字不能精确表述的确带来一些问题。看下这段代码：12345var x = .3 - .2; // 30美分减去20美分var y = .2 - .1; // 20美分减去10美分x == y // =&gt; false:两值不相等x == .1 // =&gt; false: .3-.2不等于 .1y == .1 // =&gt; true: .2-.1等于.1 由于舍入误差，0.3和0.2之间的近似差值实际上不等于0.2和0.1之间的近似差值注译1。这个问题并不只在Javascript中才出现，理解这一点非常重要：在任何使用二进制浮点数的编程语言都会有这个问题。通过需要主要的是，上述代码中x和y的值非常接近彼此和最终的正确值。这种计算结果可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等的时候才会出现。 Javascript的未来版本或许会支持十进制数字类型以避免这些舍入问题。在这之前你可以更愿意使用大整数进行重要的金融计算，例如，要使用整数“分”而不要使用小数“圆”进行基于货币单位的运算。 注译1：在Javascript的真实环境中，0.3-0.2=0.099 999 999 999 999 98","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript作用域链详解","slug":"Javascript作用域链详解","date":"2017-09-30T07:41:32.000Z","updated":"2017-09-30T08:32:53.433Z","comments":true,"path":"2017/09/30/Javascript作用域链详解/","link":"","permalink":"/2017/09/30/Javascript作用域链详解/","excerpt":"学习的时候碰到了作用域链，但是书上用了大块文字说明作用域链的机制，所以我写一篇文章，以梳理作用域链的知识。","text":"学习的时候碰到了作用域链，但是书上用了大块文字说明作用域链的机制，所以我写一篇文章，以梳理作用域链的知识。 作用域链的变量解析每一段Javascript（全局代码或函数）都有一个与之关联的作用域链（scope chain）。scope n. 范围；余地；视野；眼界；导弹射程 vt. 审视 这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。 当Javascript需要查找变量x的值的时候（这个过程称作“变量解析”），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值。 如果没有一个对象拥有属性x，则会抛出一个错误。123 对象A =&gt; 对象B =&gt; 对象C——————————————————————————&gt; 作用域链 作用域链的更新不嵌套时作用域链在不包括嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。123456789// 对于一个不嵌套的函数function f(x) &#123;&#125;// 作用域链为对象A &#123; 函数参数x： 局部变量：&#125; ↓全局对象window &#123; &#125; 作用域链创建规则当调用这个函f(x)时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。 对于嵌套函数，事情更加有趣。 每次调用外部函数时，内部函数都会重新定义一次。因为每次调用外部函数的时候，作用域链都是不同的。 内部函数在每次定义的时候都有微妙查表——在每次调用外部函数的时候，内部函数的代码都是相同的，而且关联这段代码的作用域链也不想他。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript全局变量声明和不声明的区别","slug":"Javascript全局变量声明和不声明的区别","date":"2017-09-30T07:41:12.000Z","updated":"2017-09-30T08:01:29.511Z","comments":true,"path":"2017/09/30/Javascript全局变量声明和不声明的区别/","link":"","permalink":"/2017/09/30/Javascript全局变量声明和不声明的区别/","excerpt":"在非严格模式下，利用var声明全局变量，和不用var声明直接赋值，两者在普通的使用上几乎是一样的。唯一的区别是能够被delete。","text":"在非严格模式下，利用var声明全局变量，和不用var声明直接赋值，两者在普通的使用上几乎是一样的。唯一的区别是能够被delete。 当声明一个Javascript全局变量时，实际上是定一个全局变量的属性。 当使用var声明一个变量时，创建的这个属性是不可配置的，也就是收这个变量无法通过delete运算符删除。 如果你没有使用严格模式并给一个未声明的变量赋值的话，Javascript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们： 下面分别通过不同的方式创建全局变量：123var truevar = 1; // 声明一个不可删除的全局变量fakevar = 2; //创建全局对象的一个可删除属性this.fakevar2 = 3; // 同上 利用delete删除变量123delete truevar // =&gt; falsedelete fakevar // =&gt; truedelete this.fakevar2 // =&gt; true true: 变量被删除false: 变量并没有被删除","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript函数作用域","slug":"Javascript函数作用域","date":"2017-09-30T07:05:25.000Z","updated":"2017-09-30T07:21:32.193Z","comments":true,"path":"2017/09/30/Javascript函数作用域/","link":"","permalink":"/2017/09/30/Javascript函数作用域/","excerpt":"在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域，而Javascript没有块级作用域的概念，取而代之的是函数作用域。——摘录自犀牛书","text":"在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域，而Javascript没有块级作用域的概念，取而代之的是函数作用域。——摘录自犀牛书 Javascript的函数作用域是指函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。Javascript的这个特性被非正式地成为声明提前，即Javascript函数里生命的所有变量都被“提前”至函数体的顶部。 来看以下代码：123456var scope = \"global\";function f() &#123; console.log(scope); // 输出\"undefined\"，而不是\"global\" var scope = \"local\"; console.log(scope); // 输出\"local\"&#125; 你可能会误以为函数中的第一行会输出”global”，因为代码还没执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部遮盖了同名全局变量。尽管如此，只有在程序执行到var语句的时候，局部变量才真正赋值。因此，上述过程等价于： 将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：123456function f() &#123; var scope; console.log(scope); scope = \"local\"; console.log(scope);&#125; ————以上摘录自《Javascript权威指南》 总结：为了避免声明提前而使访问值变为undefined，尽可能地在狭小的作用域中让变量声明和使用变量的代码尽可能靠近彼此。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript对象转换为原始值详解","slug":"Javascript对象转换为原始值详解","date":"2017-09-30T05:30:52.000Z","updated":"2017-09-30T07:04:12.624Z","comments":true,"path":"2017/09/30/Javascript对象转换为原始值详解/","link":"","permalink":"/2017/09/30/Javascript对象转换为原始值详解/","excerpt":"对象到布尔值的转换非常简单，所有的对象（包括包装对象）都会转换为true。而对象到数字、对象到字符串，则涉及到两个方法：toString和valueOf，情况相当复杂。就此做知识归纳。","text":"对象到布尔值的转换非常简单，所有的对象（包括包装对象）都会转换为true。而对象到数字、对象到字符串，则涉及到两个方法：toString和valueOf，情况相当复杂。就此做知识归纳。 所有的对象继承了两个转换方法。第一个是toString(),它的作用是返回一个反映这个对象的字符串。 另一个转换对象的函数是valueOf()。默认的valueOf()方法简单地返回对象本身。 下面对这两个函数进行详细分析： toString()实例不同的对象对toString()的实现不一样：12345(&#123;x:1, y:2&#125;).toString() // =&gt; \"[object, Object]\"[1,2,3].toString() // =&gt; \"1,2,3\"(function(x) &#123; f(x); &#125;).toString() // =&gt; \"function(x) &#123;\\n f(x);\\n&#125;\"/\\d+/g.toString() // =&gt; \"/\\\\d+/g\"new Date(2010,0,1).toString() // =&gt; \"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)\" 从上面的实例可以发现，对于一般对象{}，函数返回的字符串确实没有太大价值意义。而function和RegExp直接返回的是实现定义和直接量字符串，Date对象则通过一定的规则转换后得到近似于直接量的字符串。数字[]则是使用了join(“,”)方法，将各个子值拼在一起。 valueOf()实例12345(&#123;x:1, y:2&#125;).valueOf() // =&gt; Object &#123;x: 1, y: 2&#125; 对象[1,2,3].valueOf() // =&gt; [1, 2, 3](function f(x) &#123; f(x); &#125;).valueOf() // =&gt; function f(x) &#123; f(x); &#125; 对象/\\d+/g.valueOf() // =&gt; /\\d+/gnew Date(2010,0,1).valueOf() // =&gt; 1262275200000 对比toString()可以看到，valueOf()对数组、正则、函数、普通对象都只会返回他们自己本身。Date对象返回的是从1970年1月1日开始计算的毫秒数，属于数值类型。 对象与运算符原则和“==”一样， “&lt;”运算符以及其他关系运算符也会做对象到原始值的转换，但除去日期对象的特殊情况。 任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。 看下面例子：123(function f()&#123;return&#125;) &gt; 1 // =&gt; false(function f()&#123;return&#125;) &lt; 1 // =&gt; false(function f()&#123;return&#125;) = 1 // =&gt; false 函数对象先是经过valueOf()转换得到自身，再通过toString()获得&quot;function(x) {\\n f(x);\\n}&quot;的定义表达式，本质是一个字符串。字符串和一个数字比较都会获得false布尔值，由此解释上面的结果。 日期对象在运算符前，日期对象类型的转换稍微不一样，可以观察下面例子：12345var now = new Date(); // 创建一个日期对象typeof (now + 1) // =&gt; \"string\"typeof (now - 1) // =&gt; \"number\"now == now.toString() // =&gt; truenow &gt; (now - 1) // =&gt; true 在+号运算加合数字的时候，日期对象使用toString()会变换为字符串，再将1变成&quot;1&quot;字符串，通过+拼合，得到的结果为&quot;Sat Sep 30 2017 14:11:17 GMT+0800 (中国标准时间)1&quot;。而非使用valueOf()变成数值，在此基础上加一。在使用日期对象进行运算的时候，应该显式转换为数值，再进行运算。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中小数点的处理","slug":"Javascript中小数点的处理","date":"2017-09-29T16:30:12.000Z","updated":"2017-09-29T16:53:38.188Z","comments":true,"path":"2017/09/30/Javascript中小数点的处理/","link":"","permalink":"/2017/09/30/Javascript中小数点的处理/","excerpt":"在处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数计数法。","text":"在处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数计数法。 Number类为数字到字符串的转换提供三个方法toFixed()、toExponential()、toPrecision(),它们都有一个必须的数值参数。 先定一个数字1var n = 123456.789 toFixed 固定的根据小数点后的指定位数将数字转换为字符串。它从不使用指数记数法123n.toFixed(0); // \"123457\"n.toFixed(2); // \"123456.79\"n.toFixed(5); // \"123456.78900\" toExponential 指数的使用指数记数法将数字转换为指数类型的字符串，其中小数点前只有一位，小数点后的位数则由参数指定12n.toExponential(1); // \"1.2e+5\"n.toExponential(3); // \"1.235e+5\" toPrecision 精密的根据指定的有效数字位数将数字转换成字符串。如果有效数字少于数字整数部分的位数，则转换成指数形式。123n.toPrecision(4); // \"1.235e+5\"n.toPrecision(7); // \"123456.8\"n.toPrecision(10); // \"123456.7890\" 我们注意到，所有三个方法都会适当地进行四舍五入或填充0. 另外，toExponential、toPrecision的转换都是不可逆，无法通过toString变成原始值。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中数字进制的转换","slug":"Javascript中数字进制的转换","date":"2017-09-29T16:05:44.000Z","updated":"2017-09-29T16:43:13.703Z","comments":true,"path":"2017/09/30/Javascript中数字进制的转换/","link":"","permalink":"/2017/09/30/Javascript中数字进制的转换/","excerpt":"看犀牛书的时候，看到了一些数值转换的方法，再次记录一下。","text":"看犀牛书的时候，看到了一些数值转换的方法，再次记录一下。 javascript中的数值转换利用的是全局函数parseInt()和包装对象方法toString()。 parseInt()parseInt()可以将任意字符串转换成十进制整数，前提是字符串符合要求。1parseInt(\"3 blind mice\") // =&gt; 3 对于以0x开头的字符串，函数会自动解析为十六进制字符串12parseInt(\"0xFF\") // =&gt; 255parseInt(\"0xff\") // =&gt; 255 也可以接受第二个可选参数，用来指定数字转换的基数1parseInt(\"077\", 8) // =&gt; 63 (7*8 + 8) 在ECMAScript 3中，parseInt()是可以对以前缀”0”开头的的数字进行八进制的转换，到了ECMAScript 5之后就被禁止了。如果需要做八进制的转换，需要显式设置。 s.toString()先随便定义一个字符串1var n = \"17\"; 关于这个函数的转换机制就不多说了，直接上实例：123var binary_string = n.toString(2) // 转换为\"10001\"var octal_string = \"0\" + n.toString(8) // 转换为\"021\"var hex_string = \"0x\" + n.toString(16) // 转换为\"0x11\" 利用这两个函数，即可在页面上进行随意的数字进制转换。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"git入门——安装","slug":"git入门——安装","date":"2017-09-24T13:51:38.000Z","updated":"2017-09-24T14:31:50.893Z","comments":true,"path":"2017/09/24/git入门——安装/","link":"","permalink":"/2017/09/24/git入门——安装/","excerpt":"如果有很多台电脑，每次都要看看找找教程再安装太麻烦了，干脆在这里写好然后多看看。","text":"如果有很多台电脑，每次都要看看找找教程再安装太麻烦了，干脆在这里写好然后多看看。 安装windows上面的安装下载安装 git for windows Ubuntu上面的安装1$ sudo apt-get install git git的设置因为Git是分布式版本管理系统，所以，每台机器必须自报家门12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 创建版本库创建库文件夹在一个合适的地方创建文件夹12$ mkdir learngit$ cd learngit 初始化文件夹1$ git init 这时候会创建一个名为.git的文件夹。 远程仓库创建SSH KEY1$ ssh-keygen -t rsa -C \"youremail@example.com\" 这时候会在主目录下找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 Add SSH KEY登录GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 远程推送在本地仓库下执行1$ git remote add origin git@github.com:michaelliao/learngit.git 然后将本地的所有内容都推送到远程库上1git push -u origin master 在以后，只要在本地作业，就能通过命令推送到github1git push origin master 克隆库1git clone","categories":[{"name":"网站维护","slug":"网站维护","permalink":"/categories/网站维护/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"git入门——常用操作","slug":"git入门——常用操作","date":"2017-09-24T05:50:03.000Z","updated":"2017-09-24T15:00:32.640Z","comments":true,"path":"2017/09/24/git入门——常用操作/","link":"","permalink":"/2017/09/24/git入门——常用操作/","excerpt":"看了一下廖雪峰的git教程，觉得要熟悉git的操作需要一段适应时间，于是我干脆在这里写一篇总结性的git常用操作集合，方便自己日后推送和维护项目。","text":"看了一下廖雪峰的git教程，觉得要熟悉git的操作需要一段适应时间，于是我干脆在这里写一篇总结性的git常用操作集合，方便自己日后推送和维护项目。 日常操作12345678910$ git add filename #添加文件$ git commit -m \"some message\" #提交文件$ git status #查看状态$ git diff #查看修改内容$ git log --pretty=oneline #查看提交记录$ git reset --hard HEAD^ #退回上一个版本$ git reflog #查看命令历史$ git checkout -- filename #丢弃工作区的修改$ git reset HEAD filename #丢弃缓存区的修改$ git rm filename #删除文件 分支的使用123456789$ git branch dev #创建分支$ git checkout dev #切换分支$ git checkout -b dev #创建并切换分支$ git branch #查看分支$ git merge dev #合并分支$ git branch -d dev #删除分支$ git merge --no-ff -m \"some message\" dev #合并的同时commit$ git push origin master #推送master主分支$ git push origin dev #推送dev分支 工作现场stash123456$ git stash #存储工作现场$ git stash list #查看工作现场$ git stash apply #恢复工作现场$ git stash drop #删除工作现场$ git stash pop #恢复和删除工作现场$ git stash apply stash@&#123;0&#125; #恢复指定stash 标签tag标签可以用来管理版本号，一般标记在master分支上123456789101112131415$ git tag v1.0 #为当前分支打上标签$ git tag #查看所有标签$ git tag v0.9 6224937 #为指定commit打上标签$ git tag -a v0.1 -m \"version 0.1 released\" 3628164 #附带信息$ git show v0.9 #查看标签信息$ git tag -d v0.1 #本地删除标签$ git push origin v1.0 #远程推送标签$ git push origin --tags #远程推送所有标签删除远程标签// 先从本地删除$ git tag -d &lt;tagname&gt;// 再从远程删除$ git push origin :refs/tags/&lt;tagname&gt; 远程协作12345678910111213141516171819202122232425262728//克隆远程仓库$ git clone git@github.com:michaelliao/learngit.git//创建本地dev分支$ git checkout -b dev origin/dev对dev修改后可以推送提交//推送dev分支$ git push origin dev如果其他人已经推送了新的版本，会显示有冲突//将其他人最新的提交抓去下来$ git pull但是git pull会失败，原因是没有设置链接//建立本地分支和远程分支的关联$ git branch --set-upstream branch-name origin/branch-name//合并库$ git commit -m \"merge &amp; fix hello.py\"如果有冲突，就解决掉//再次推送到dev分支上$ git push origin dev","categories":[{"name":"网站维护","slug":"网站维护","permalink":"/categories/网站维护/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"JQuery增删cookie","slug":"JQuery增删cookie","date":"2017-09-22T15:03:07.000Z","updated":"2017-09-22T15:48:53.182Z","comments":true,"path":"2017/09/22/JQuery增删cookie/","link":"","permalink":"/2017/09/22/JQuery增删cookie/","excerpt":"有一些项目需要大量部署cookie增删的代码，比如登录系统。通过使用jquery.cookie.js插件，实现JQuery对cookie的控制。","text":"有一些项目需要大量部署cookie增删的代码，比如登录系统。通过使用jquery.cookie.js插件，实现JQuery对cookie的控制。 引入jquery.cookie.js库文件 下载jquery.cookie.jsCSDN下载地址下载需要1积分，申请帐号后做点小任务吧。 引入jquery和cookie插件。要先引入jQuery的库文件，和 jquery.cookie.js 的库文件。 需要注意的是：JQuery必须先行引入，而后才是cookie文件，反正则错误。 来看一个例子：1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;js中字符串处理&lt;/title&gt; &lt;/head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.8.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.cookie.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function newCookieFunc()&#123; $.cookie('cookieId',\"201211011\",&#123;expires:2,path: '/'&#125;); $.cookie('cookieName',\"linzhiqiang\",&#123;expires:2,path: '/'&#125;); alert(\"新建cookie成功，值分别为：cookieId：201211011 cookieName：linzhiqiang\"); &#125;; function getCookieFunc()&#123; var cookieId=$.cookie('cookieId'); var cookieName=$.cookie('cookieName'); alert(\"cookie的值分别为：cookieId：\"+cookieId+\" cookieName：\"+cookieName); &#125;; function deleteCookieFunc()&#123; $.cookie('cookieId',null,&#123;expires:-1,path: '/'&#125;); $.cookie('cookieName',null,&#123;expires: -1,path: '/'&#125;); alert(\"删除cookie成功\"); &#125;; &lt;/script&gt; &lt;body&gt; &lt;input type=\"button\" onclick=\"newCookieFunc();\" value=\"利用JQuery新建cookie信息\"&gt;&lt;/br&gt; &lt;input type=\"button\" onclick=\"getCookieFunc();\" value=\"利用JQuery读取cookie信息\"&gt;&lt;/br&gt; &lt;input type=\"button\" onclick=\"deleteCookieFunc();\" value=\"利用JQuery删除cookie信息\"&gt;&lt;/br&gt; &lt;/body&gt; &lt;/html&gt; cookie参数解析1. expires: 365定义cookie的有效时间，值可以是一个数字（从创建cookie时算起，以天为单位）或一个Date 对 象。如果省略，那么创建的cookie是会话cookie，将在用户退出浏览器时被删除。2. path: ‘/‘默认情况：只有设置cookie的网页才能读取该cookie。 定义cookie的有效路径。默认情况下，该参数的值为创建 cookie 的网页所在路径（标准浏览器的行为）。如果你想在整个网站中访问这个cookie需要这样设置有效路径：path: ‘/‘。如果你想删除一个定义 了有效路径的 cookie，你需要在调用函数时包含这个路径:$.cookie(‘the_cookie’, null, { path: ‘/‘ });。 domain: ‘example.com’ 默认值：创建 cookie的网页所拥有的域名。3. secure: true默认值：false。如果为true，cookie的传输需要使用安全协议（HTTPS）。4. raw: true默认值：false。 默认情况下，读取和写入 cookie 的时候自动进行编码和解码（使用encodeURIComponent 编码， decodeURIComponent 解码）。要关闭这个功能设置 raw: true 即可。 参考文章——CSDN","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"/tags/JQuery/"},{"name":"cookie","slug":"cookie","permalink":"/tags/cookie/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"碰巧生而为人","slug":"碰巧生而为人","date":"2017-09-22T14:31:35.000Z","updated":"2017-09-22T15:00:31.797Z","comments":true,"path":"2017/09/22/碰巧生而为人/","link":"","permalink":"/2017/09/22/碰巧生而为人/","excerpt":"偶然看到了一些很有意义的文章，同时也阅读了一些有思考性的书籍，我想通过一篇文章，阐述一下我对人和死亡的思考。由此写下这篇文章。这个故事讲述一个灵魂的不断轮回，由糜烂到新生，导出生而为人的意义。","text":"偶然看到了一些很有意义的文章，同时也阅读了一些有思考性的书籍，我想通过一篇文章，阐述一下我对人和死亡的思考。由此写下这篇文章。这个故事讲述一个灵魂的不断轮回，由糜烂到新生，导出生而为人的意义。 一个让人难以忍受的夏天，我在树上呐喊。而不知为何，此生之始，我便拥有前世的记忆。 那时第一次拥有意识，碰巧生而为人。 记忆中是个遥远的时代，我生于帝王世家。我父亲是天下江山之主，我是他唯一的儿子，也是将来继承父亲王位之人。 四岁那年，父亲请来了全国最好的先生，向我传道授业。先生学识渊博，宽以待人，对我的栽培十分用心。但我辜负了先生的期望，终日嬉戏游玩，不思进取。在先生的一次阻拦中，我用皇家传承之剑刺向了他。先生离去之后，我更荒废度日。在皇城内，有绝世美人的歌舞，有天下厨神开设盛宴。偶然腰钱万贯，坐最豪华的船只游览大河，一去数月，尾随仆从数百。 有一个年轻人脸上有颗痣，在我面前路过。我看不顺眼，找人折磨他，把他的身体一块一块切下来。他在一片尖叫和血水死去，而身边没有一个人敢言半句。那一刻我发现，自己竟然看其他人如畜生一般。 糜烂的日子没有一天消停过，父皇多次请来先生给我上课，而我不屑一顾。不久，国家分崩离析，父皇重病一卧不起。在我在举行杀人比赛的过程中，一些身穿盔甲的人闯进我的寝室，给我射了一箭。临死前，镜子中映照着自己肥硕的身躯。那一刻我发现，自己竟然碰巧生而像人罢了。 大概是上天的惩罚吧，我开始了作为畜生轮回。 记得一次我作为家禽，每天吃着同样的饲料，看着一样的天空。那些称鸡哥鸭哥的兄弟们，只会在原地打转，双目无神，眼看着他们一天比一天肥胖，数量一天比一天少。终于有一天，我被抓住了翅膀，刀在我脖子落下。我意识到，自己将成为“猴子”餐桌上的美食，我的一生已经终结。 我又进入了家禽的轮回，某日我发现自己受够了。 记得那次我又是作为家禽，吃着一样的饲料，关进类似的牢笼。天下大雨，地上有积水。我惊讶地发现脚下的倒影跟我眼前的兄弟们如出一辙，似乎餐桌上的那块肉是谁都可以。我意识到自己短暂的生命，逃不过人类的屠刀，逃不过天敌的爪牙。那个晚上，我没有闭上过眼睛，第二天，绝食死了。 记得一次我作为家猪，逃出了那个“同类”的牢笼，向森林奔去，对那时候的我来说，外面有我的自由，是我作为家猪的梦想。但命运似乎没有打算放过我。我剧烈奔跑，滚下了山崖，死了。 轮回稍微不一样，这次我天生拥有“自由”。 记得一次我作为野狼，总为食物四处奔波，碰巧进入了某个小村落。一个房子里面有一个自己的“同类”，他说自己生活很好，不愁吃不愁住，还邀请自己一同居住。我仅仅给了他一个鄙夷眼神，便走开了。我跟伙伴一同捕猎村中的羊，不慎掉进陷阱里。绝望和饥渴，让我们互食同类。这本是我追求的自由，但是到底有什么不对？ 我又坠入轮回，在今生以蝉诞生。 回忆起前世的种种事情，我希望实现自己的梦想，那就是能在人间留下痕迹。于是我爬上了树，日夜不休地鸣叫。也许我永远无法弥补以前的过错，或许此生知前世只是一个上天的失误。一旦我闭上了眼睛，再次睁开可能是猪的模样。但是我真的很希望，人间有人能记住我。 在第十五个夏日里，我气绝身亡。 时间过得飞快，无数高楼立地而起。在时间的某个断点，一个小伙子健康出生。他本能般抓住自己身边的一点一滴，尝试为身边带来欢乐。他说他自己的梦想是成为一个音乐家，让他原创的音乐留存在每个人心中。 某日，一家意大利快餐店播放着本年度最流行的音乐，电视机播放《动物世界》一头狼的故事，而作曲者他在摆弄着炽热的猪扒。突然上天在他耳边低语，唤醒他前世的记忆。 他喜极而泣，他说，感谢自己碰巧生而为人。","categories":[{"name":"短篇小说","slug":"短篇小说","permalink":"/categories/短篇小说/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"/tags/短篇小说/"}]},{"title":"ajax+flask模拟表单提交","slug":"ajax-flask模拟表单提交","date":"2017-09-22T14:30:58.000Z","updated":"2017-09-22T16:02:07.395Z","comments":true,"path":"2017/09/22/ajax-flask模拟表单提交/","link":"","permalink":"/2017/09/22/ajax-flask模拟表单提交/","excerpt":"首先，当前端页面存在表单时，默认的commit往往不符合预期。即使页面html中存在表单验证功能，效果甚微。而commit之后不管三七二十一直接跳转到另一个页面，如果这符合你预期固然好，不过我一般还是用xhr(XMLHttpRequest)定制自己commit的事件","text":"首先，当前端页面存在表单时，默认的commit往往不符合预期。即使页面html中存在表单验证功能，效果甚微。而commit之后不管三七二十一直接跳转到另一个页面，如果这符合你预期固然好，不过我一般还是用xhr(XMLHttpRequest)定制自己commit的事件 前端首先取得commit的按钮节点1btn = form['commit-btn']; 取消默认行为12345678btn.onclick = function(e) &#123; e.preventDefault(); submit_btn.disabled = true; //禁用commit按钮 //表单验证 //数据处理 //xhr模拟提交 //相应后的操作&#125; 这里需要注意一下。return false也是可以阻止默认行为，但我们一般还需要表单验证，直接就return自然不符合我们的预期。禁用commit按钮是为了避免重复提交表单，需要启用按钮就改为=false就可以。 数据处理1234567// 基本格式name = '丽江';text = 'abc';name = encodeURIComponent(name);text = encodeURIComponent(text);data = 'name=' + name + '&amp;' + 'text=' + text;//name=%E4%B8%BD%E6%B1%9F&amp;text=abc xhr模拟表单提交12345xhr = new XMLHttpRequest();url = '/abc'; //自行修改地址xhr.open(\"post\", url,false); //同步提交为false，异步可以用truexhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");//模拟表单需要修改headerxhr.send(data);//传输数据 获取相应后再操作页面12345678if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status == 304 ) &#123; submit_btn.disabled = false; //刷新页面 location.reload(); &#125; else &#123; alert('评论失败，请检查你的网络'); submit_btn.disabled = false; &#125; 提交失败后不要忘记将submit_btn开启(设置disable = false) 后台假设你有一个app.py1234567891011121314from flask import Flask,requestimport urllibfrom urllib import parseapp = Flask(__name__)@app.route('/abc',methods=['POST'])def comment_write(html_src): #一顿操作 passif __name__ == '__main__': app.run(host='0.0.0.0',port=80) //外网访问，host是关键 获取表单内容123name = urllib.parse.unquote(request.form['name']) #丽江text = urllib.parse.unquote(request.form['text']) #abc#unquote方法用来解析url参数 对post请求作出响应1return 'successful' 如果不做出请求响应，前台会认为响应失败，返回400状态码，相对地，相应成功会返回200和304，部分浏览器会返回204响应码。 总结ajax模拟表单提交实际上就是取消默认操作、获取表单数据并处理、xhr发送请求、相应处理的过程。大家可能注意到，即使前台使用默认的commit提交表单，后台代码也仅仅不需要unquote而已。可以说，使用ajax提交表单跟默认提交表单，后台操作是类似的。 在数据处理方面，有值得注意的地方。data数据的格式与get方法在地址栏提交的数据格式几乎一样（就是少了个？），猜测post请求提交数据的过程与get方法提交数据的原理是相似的，只是提交方式有差异。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"/tags/flask/"},{"name":"Ajax","slug":"Ajax","permalink":"/tags/Ajax/"},{"name":"表单","slug":"表单","permalink":"/tags/表单/"}]},{"title":"手机端点击input禁止放大","slug":"手机端点击input禁止放大","date":"2017-09-22T14:28:41.000Z","updated":"2017-09-22T14:49:35.599Z","comments":true,"path":"2017/09/22/手机端点击input禁止放大/","link":"","permalink":"/2017/09/22/手机端点击input禁止放大/","excerpt":"","text":"当点击手机表单，手机会自动放大，将窗口锁定到表单组件。为了让自己的网页看起来更像一个原生的app，我决定把手机发大这一默认行为禁掉。 如果不作特殊设置，在手机端的表单输入文本框会在被点击后放大，如果想取消这一行为，可以在头部加上：1&lt;meta name=\"viewport\" content=\"width=720,inital-scale=1.0,user-scalable=no;\"&gt; 再加上css样式：1input,input:focus,input:active&#123;user-select: text;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}]},{"title":"清除iphone页面input原有样式","slug":"清除iphone页面input原有样式","date":"2017-09-22T14:28:20.000Z","updated":"2017-09-22T14:46:17.669Z","comments":true,"path":"2017/09/22/清除iphone页面input原有样式/","link":"","permalink":"/2017/09/22/清除iphone页面input原有样式/","excerpt":"","text":"我在做网站的时候遇到过这样的问题: 自己手机预览的页面跟其他手机的不一样。最初以为是手机浏览器问题，跑了一下acid，性能评分100，瞬间就蒙了。考虑到浏览器本身漏洞没有被测出来，用wechat测试了一下页面，预览结果还是不符合预期。最后，发现是iphone自身样式所致。 如果没有给页面的input和textarea设定详细的css样式，iphone显示的页面效果很可能跟自己在chrome上的有出入。原因是iphone页面显示有自带样式，，比如iphone的input圆角半径会较一般浏览器大，可能是内核问题（欢迎补充）。所以编写CSS的时候不要依赖调试浏览器中显示的样式，尽可能地给input设置详细的样式，当然，也可以使用一下代码： 123456input[type=\"text\"],input[type=\"button\"],input[type=\"submit\"],input[type=\"reset\"] &#123;-webkit-appearance: none;&#125;textarea &#123;-webkit-appearance: none;&#125; 参考资料——CSDN","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}]},{"title":"Ubuntu初体验（三）——ftp安装和配置","slug":"Ubuntu初体验（三）——ftp安装和配置","date":"2017-09-21T16:19:03.000Z","updated":"2017-09-22T13:01:21.820Z","comments":true,"path":"2017/09/22/Ubuntu初体验（三）——ftp安装和配置/","link":"","permalink":"/2017/09/22/Ubuntu初体验（三）——ftp安装和配置/","excerpt":"一般编辑文件都会在本地，服务器负责提供服务的。我将系统文件准备好，然后通过ftp推送给Ubuntu，过程很快而且很简单。","text":"一般编辑文件都会在本地，服务器负责提供服务的。我将系统文件准备好，然后通过ftp推送给Ubuntu，过程很快而且很简单。 文章大部分来自百度经验帖（文末），图片同样来自百度经验帖。由于按照百度经验操作会有一些坑，所以就自己写一篇更完整的博客。win10 + 阿里云 Ubuntu 14.05 安装一个基本的文本编辑器（gedit）12sudo apt-get install gedit #安装sudo apt-get remove gedit #卸载 Ubuntu中ftp的安装更新源列表1sudo apt-get update 安装vsftpd1sudo apt-get install vsftpd 判断vsftpd是否安装成功1sudo service vsftpd restart 新建用户主目录1sudo mkdir /home/uftp 查看是否成功。显示/home下所有可见文件夹。1sudo ls /home 新建用户uftp并设置密码。12sudo useradd -d /home/uftp -s /bin/bash uftp #新建用户名uftpsudo passwd uftp #依次输入两次密码即可 使用gedit修改配置文件/etc/vsftpd.conf1sudo gedit /etc/vsftpd.conf 向文件中添加添加12345userlist_deny=NOuserlist_enable=YESuserlist_file=/etc/allowed_usersseccomp_sandbox=NO 同时修改1local_enable=YES 保存 使用gedit新建/etc/allowed_users文件打开”终端窗口”，输入1sudo gedit /etc/allowed_users 输入uftp–&gt;保存 使用gedit查看/etc/ftpusers文件中的内容1sudo gedit /etc/ftpusers 打开这个文件后，看一看有没有uftp这个用户名，如果没有，就直接退出。如果有就删除uftp,因为这个文件中记录的是不能访问FTP服务器的用户清单。 win端的配置使用winscp登录FTP服务器除了winscp之外，还有很多优秀的ftp传输软件，如FileZilla,Xftp等。 下载安装WinSCP，运行WinSCP–&gt;输入IP、用户名、密码–&gt;保存–&gt;勾选”保存密码”–&gt;确定–&gt;登录–&gt;登录成功 如果上传失败(大坑)返回服务器终端1chmod -R 777 /home/uftp 修改配置文件1sudo gedit /etc/vsftpd.conf 添加12local_root=/home/uftpwrite_enable=YES 重启vsftpd服务1service vsftpd restart 参考资料——百度经验参考资料——550 Permission denied参考资料——553 Could not create file","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"Ubuntu初体验（二）——常用软件安装","slug":"Ubuntu初体验（二）——常用软件安装","date":"2017-09-21T16:18:29.000Z","updated":"2017-09-21T16:41:49.413Z","comments":true,"path":"2017/09/22/Ubuntu初体验（二）——常用软件安装/","link":"","permalink":"/2017/09/22/Ubuntu初体验（二）——常用软件安装/","excerpt":"安装过中文桌面后，还有一些常用的软件需要下载，如winrar等。对于是否安装软件，我的建议是能少就少，有什么从本地ftp推给服务器。","text":"安装过中文桌面后，还有一些常用的软件需要下载，如winrar等。对于是否安装软件，我的建议是能少就少，有什么从本地ftp推给服务器。 安装搜狗输入法 用自带的浏览器（gnome的是firefox）打开网址http://pinyin.sogou.com/linux/?r=pinyin 下载你需要的输入法版本，我这里是64位版的Ubuntu 下载完成后安装deb文件，跟着提示操作即可。 在终端输入im-config。跟着出现的对话框，点击&gt;OK&gt;yes，点击fcixt&gt;OK。 重启服务器，开始使用sogou输入法 参考文章 安装文本编辑器(atom为例) 使用PPA下载 123sudo add-apt-repository ppa:webupd8team/atomsudo apt-get updatesudo apt-get install atom 执行第一条的时候可能会报错sudo:add-apt-repository:command not found 终端运行以下命令后再使用PPA 12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 如果你想卸载 12sudo apt-get remove atomsudo add-apt-repository --remove ppa:webupd8team/atom WinRAR安装12sudo apt-get install rarsudo ln -fs /usr/bin/rar /usr/bin/unrar","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"Ubuntu初体验（一）——配置桌面环境","slug":"Ubuntu初体验（一）——配置桌面环境","date":"2017-09-21T15:22:49.000Z","updated":"2017-09-21T16:36:41.912Z","comments":true,"path":"2017/09/21/Ubuntu初体验（一）——配置桌面环境/","link":"","permalink":"/2017/09/21/Ubuntu初体验（一）——配置桌面环境/","excerpt":"阿里云的服务器，如果使用的是Linux系统，一开始只有命令行界面，对于想要好好学习的我简直吓坏了，所以安装一个界面方便使用。不过要注意，安装桌面环境会一定程度上降低服务器的性能，但是对于我这种简单部署就不会有大的阻碍。","text":"阿里云的服务器，如果使用的是Linux系统，一开始只有命令行界面，对于想要好好学习的我简直吓坏了，所以安装一个界面方便使用。不过要注意，安装桌面环境会一定程度上降低服务器的性能，但是对于我这种简单部署就不会有大的阻碍。 由于我以前使用的是国产的deepin，之后使用阿里云Ubuntu的时候简直吓坏了，只有命令行界面。在安装桌面环境的时候也遇到了各种各样的问题，比如说中文乱码问题。Ubuntu14.05 桌面gnome3.9 安装桌面环境升级一下12sudo apt-get updatesudo apt-get upgrade 安装gnome3.9桌面依次输入以下命令123apt-get install x-window-system-coreapt-get install gnome-coreapt-get install gdm 输入startx进入桌面环境。可以看到桌面重启后会让你输入root的帐号密码， gnome界面 配置中文环境 有些桌面界面会配置好中文环境（至少deepin对中文很友好，毕竟是国产的），而一般外国的桌面都是英文的，连中文都打不进去，更不要说修改什么什么东西了。当我用ftp传输文件的时候，中文会变成带数字的方块。 首先查看一下系统的设定。进入gnome的system setting，查看Region Language，在Language一栏，发现一开始并没有Chinese选项。（如果有，设定为Chinese后重启大概完事） 返回终端,执行以下命令sudo apt-get install language-pack-zh-han*这样可以安装中文包。 安装完成后重启服务器。这时候可以在Language一栏看到Chinese，将Language改为Chinese，并且把input Sources改为Chinese。 再次重启服务器。重启后发现系统很多原本是英文的地方变成了白色矩形。推测是已经将系统语言变成中文，但是系统并没有装载任何中文字体。 安装中文字体先安装一个字体 12sudo apt-get install xfonts-wqy #文泉驿-正黑sudo apt-get install ttf-wqy-zenhei #思源黑体 进入到字体目录下/usr/share/fonts/ 1cd /usr/share/fonts/ 更新字体 1sudo fc-cache -fv 这时候应该能正常显示中文了。","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"Nginx+uWSGI+flask部署app环境","slug":"Nginx-uWSGI-flask部署app环境","date":"2017-09-21T15:09:24.000Z","updated":"2017-09-22T14:07:02.035Z","comments":true,"path":"2017/09/21/Nginx-uWSGI-flask部署app环境/","link":"","permalink":"/2017/09/21/Nginx-uWSGI-flask部署app环境/","excerpt":"想有一个响应速度快、后台稳定的服务器环境，仅靠框架（比如flask）自带服务器系统是不足够的。利用Nginx和uWSGI,实现强有力的服务器环境，可以让页面相应速度上升几十倍。","text":"想有一个响应速度快、后台稳定的服务器环境，仅靠框架（比如flask）自带服务器系统是不足够的。利用Nginx和uWSGI,实现强有力的服务器环境，可以让页面相应速度上升几十倍。 以前用过纯JS写过一个博客，但是毕竟自己研究前端比较多，对于后台配置不太熟悉。当时使用了flask做后台框架，由于flask自带服务器系统，所以平时就开flask服务器就算了。后来发现，flask自带的服务器非常不稳。由于社团项目需要，通过同学的推荐，我决定使用这么一套技术栈搭建后台。Ubuntu 14.04.05 + mysql + uWSGI + python3 + git 安装mysql 终端安装mysql 12345sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev# 用下面语句检查是否安装成功sudo netstat -tap | grep mysql 安装mysql时会有一个用户名debian-sys-maint和一个随机密码。 1sudo vi /etc/mysql/debian.cnf 找到帐号密码然后登录mysql命令行 1mysql -u debian-sys-maint -p 进入控制台后，修改密码 12use mysql;update user set password=PASSWORD('新密码') where user='root'; FLUSH PRIVILEGES; 输入quit退出控制台。 python3安装 终端安装python3 1sudo apt-get install python3 安装pip3 1sudo apt-get install python3-pip 顺便安装pip 1sudo apt-get install python-pip 再把mysql的python驱动装了吧 1sudo pip3 install mysqlclient 安装git1sudo apt-get install git 配置代码运行的环境Python的虚拟环境，可以隔离各个项目，避免python版本冲突1sudo pip3 install virtualenv 假设我的项目目录是/home/jnugeek，进入根目录，执行12virtualenv jnugeeksource jnugeek/bin/activate #进入虚拟环境 这样就创建了名为jnugeek的虚拟环境，直接在后台输入deactivate退出虚拟环境 uWSGI配置uWSGI是高性能http服务器，用来和Python程序交换1(jnugeek)jnugeek root$ pip3 install uwsgi 在虚拟环境下不需要使用sudo，因为virtualenv 是没有权限要求的。在项目目录下创建config.ini作为uWSGI的配置文件123456789[uwsgi]master = truehome = jnugeek #虚拟环境文件夹wsgi-file = manage.pycallable = appsocket = :5000processes = 4threads = 2buffer-size = 32768 (虚拟环境内)运行文件1uwsgi config.ini 如果没有报错的话就是可以的，但是会有一些比较坑爹的错误1!!! no internal routing support, rebuild with pcre support !!! 这个是因为pcre没弄好，一般去掉缓存重装就可以了，-I的作用是重装1pip3 install uwsgi -I --no-cache-dir 安装Flask在根目录下新建一个requirements.txt文件，输入12345678910111213141516171819202122Flask==0.10.1Flask-Login==0.2.11Flask-Mail==0.9.1Flask-Moment==0.4.0Flask-PageDown==0.1.5Flask-SQLAlchemy==2.0Flask-Script==2.0.5Flask-WTF==0.10.2Flask-Cache==0.13.1Flask-Restless==0.15.0Flask-Uploads==0.1.3Jinja2==2.7.3Mako==1.0.0Markdown==2.5.1MarkupSafe==0.23SQLAlchemy==0.9.8WTForms==2.0.1Werkzeug==0.9.6html5lib==1.0b3itsdangerous==0.24six==1.8.0awesome-slugify==1.6 安装清单文件1(jnugeek)jnugeek root$ pip3 install -r requirements.txt supervisor配置uWSGI好是好，但是要是它万一断了，或者出问题了怎么办？要是有这样的一个程序可以自动监控运行uWSGI那岂不是美滋滋，而supervisor就是这样的程序。安装1sudo apt-get install supervisor 在/etc/supervisor/conf.d/下建立一个配置文件sp.conf1234567891011[program:my_flask]# 启动命令入口command=/home/jnugeek/jnugeek/bin/uwsgi /home/jnugeek/config.ini# 命令程序所在目录directory=/home/jnugeek#运行命令的用户名user=rootautostart=trueautorestart=true#日志地址（需要手动新建文件）stdout_logfile=/home/jnugeek/logs/uwsgi_supervisor.log 启动/重启/查看状态命令1sudo service supervisor start/restart/stats 安装Nginx1sudo apt-get install nginx 新建一个default文件（无后缀）123456789101112server &#123; listen 80; server_name X.X.X.X; #公网地址 location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:5000; # 指向uwsgi 所应用的内部地址,所有请求将转发给uwsgi 处理 uwsgi_param UWSGI_PYHOME /home/jnugeek/jnugeek; # 指向虚拟环境目录 uwsgi_param UWSGI_CHDIR /home/jnugeek; # 指向网站根目录 uwsgi_param UWSGI_SCRIPT manage:app; # 指定启动程序 uwsgi_read_timeout 100; &#125; &#125; 测试一下配置是否正确1sudo nginx -t 将/etc/nginx/sites-available/default替换掉1sudo service nginx restart 将你的项目文件装载后，在浏览器中输入你的IP地址，就可以看到你的项目了。 在哪里查看错误日志呢？ /var/log/nginx/error.log 参考资料1——简书参考资料2——博客园参考资料3——同学的博客","categories":[{"name":"服务器部署","slug":"服务器部署","permalink":"/categories/服务器部署/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"/tags/Nginx/"},{"name":"uWSGI","slug":"uWSGI","permalink":"/tags/uWSGI/"},{"name":"flask","slug":"flask","permalink":"/tags/flask/"},{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"}]},{"title":"pymysql连接mysql数据库——不支持中文解决","slug":"pymysql连接mysql数据库——不支持中文解决","date":"2017-09-21T10:52:28.000Z","updated":"2017-10-25T13:35:49.593Z","comments":true,"path":"2017/09/21/pymysql连接mysql数据库——不支持中文解决/","link":"","permalink":"/2017/09/21/pymysql连接mysql数据库——不支持中文解决/","excerpt":"","text":"在mysql的学习中，我用本地的win10搭建了环境。当要将中文字符输入到mysql数据库中，就会报错。上网找了一下方法，完美解决。mysql5.7 windows10 往数据库里插入中文时出现异常:1UnicodeEncodeError: 'latin-1' codec can't encode characters 就是编码的问题,pymysql默认的编码是latin1,我们只需要把它改成utf8就好了 更改pymysql配置文件 打开Python的安装目录:Python34\\Lib\\site-packages\\PyMySQL-0.7.9-py3.4.egg\\pymysql 用记事本打开connections.py文件,找到里面的DEFAULT_CHARSET,后面默认=’latin1’,改成utf8就好了,注意是utf8不是utf-8。 PS：ubuntu中的路径为：usr/local/lib/python3.4/dist-packages/pymysql/connections.py 然而解决了问题了吗？并没有，就算我把connections.py文件所有的latin-1更改为utf8，运行py文件读写数据库依然报错。 于是有了下面的方法： 数据库连接1db = pymysql.connect('localhost', username, password, database) 改为1db = pymysql.connect('localhost', username, password, database,use_unicode=True, charset=\"utf8\") 解决 参考资料——博客园","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"},{"name":"pymysql","slug":"pymysql","permalink":"/tags/pymysql/"},{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"hexo主题indigo——配置","slug":"hexo主题indigo——配置","date":"2017-09-21T10:52:28.000Z","updated":"2017-09-21T11:29:36.217Z","comments":true,"path":"2017/09/21/hexo主题indigo——配置/","link":"","permalink":"/2017/09/21/hexo主题indigo——配置/","excerpt":"修改indigo可以个性化你的页面。由于indigo使用的是utf-8编码，不用担心中英文输入问题。图片的替换只需更好图片内容或者路径即可，相当简单。","text":"修改indigo可以个性化你的页面。由于indigo使用的是utf-8编码，不用担心中英文输入问题。图片的替换只需更好图片内容或者路径即可，相当简单。 无论是主题的安装还是配置，千万千万要看它的文档。（文档链接在末尾） 站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url 主题配置编辑主题配置文件，themes/indigo/_config.yml。 ##左侧菜单默认配置如下1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下：12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到这个页面挑选合适的图标。 favicon站点 logo，显示在浏览器当前标签页左上角。1favicon: /favicon.ico 头像位于左侧菜单上方1avatar: /img/logo.jpg email头像下方1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。1color: '#3F51B5' 页面标题 (card theme)自定义归档、标签、分类页的大标题。123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 以分割摘要与文章正文。未设置时，按 excerpt_length 设置截取。123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... 分享文章分享开关，byjiathis-api。1share: true 文章打赏默认开启1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。1hideMenu: true Toc开启文章内容导航。123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。1copyright: 这里写留言或版权声明 less设置 less 编译时的入口文件路径，hexo-renderer-less。1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了多说和 disqus，开启其一即可。 duoshuo-key 即多说创建站点时的二级域名。如：abc.duoshuo.com，就填 abc。 1duoshuo: duoshuo-key 或 1disqus_shortname: disqus_shortname 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false1about: 用户页面中作者相关的描述性文字，如不需要设为 false indigo主题配置文档","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"},{"name":"indigo","slug":"indigo","permalink":"/tags/indigo/"}]},{"title":"hexo主题indigo——安装","slug":"hexo主题indigo——安装","date":"2017-09-21T10:52:01.000Z","updated":"2017-09-21T11:12:14.855Z","comments":true,"path":"2017/09/21/hexo主题indigo——安装/","link":"","permalink":"/2017/09/21/hexo主题indigo——安装/","excerpt":"本站使用的是indigo主题。这个主题UI相对比较美观，功能齐全，但是可个性化的部分比较少，图片镶嵌不足。如果想要一个更个性化的主题，我推荐material主题。","text":"本站使用的是indigo主题。这个主题UI相对比较美观，功能齐全，但是可个性化的部分比较少，图片镶嵌不足。如果想要一个更个性化的主题，我推荐material主题。 使用indigo请先下载最新版的git和nodejs，博主曾经因为使用4.0版本的nodejs而折腾了一个下午，最终使用8.x的nodejs完美解决。文章的内容都来自文章末尾的文档链接，想要更详细的可以直接去看文档。 主题安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。1$ npm install hexo-renderer-less --save Feed用于生成 rss。1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 修改hexo配置文件用文本编辑器（建议不要用win自带的文本编辑器）打开_config.yml，修改theme: indigo 配置完成，在git bash输入hexo s预览主题。 hexo主题列表浏览更多主题indigo主题文档传送门","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"},{"name":"indigo","slug":"indigo","permalink":"/tags/indigo/"}]},{"title":"hexo入门指南（四）——文章模版","slug":"hexo入门指南（四）——文章模版","date":"2017-09-20T12:27:00.000Z","updated":"2017-09-21T15:10:44.981Z","comments":true,"path":"2017/09/20/hexo入门指南（四）——文章模版/","link":"","permalink":"/2017/09/20/hexo入门指南（四）——文章模版/","excerpt":"一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。","text":"一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。 新建页面在git bash中输入hexo new &quot;your file name&quot;在路径\\blog\\source_posts中会生成一个md文件 文章模版要注意hexo文章使用的是markdown语法，建议不要去尝试其他文本格式(虽然亲测html是有效的)。 这里附上本文的配置123456789101112---title: hexo入门指南（四）——文章模版date: 2017-09-20 20:27:00categories: \"博客建设\"tags: - Hexo教程 - githubdescription: 写文章的时候要注意---一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。&lt;!--more--&gt; 文章发布 写文章的时候，可以在git bash中输入hexo s,然后保存文章后刷新页面localhost:4000即可看到最新的变化。 想要发布文章，在git bash中输入hexo clean &amp;&amp; hexo g &amp;&amp; hexo d关于内联语句的含义，可以查看入门指南（一） 于是我们就可以轻松愉快地写文章了。","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（三）———分类和标签页","slug":"hexo入门指南（三）———分类和标签页","date":"2017-09-20T12:26:11.000Z","updated":"2017-09-21T10:40:31.621Z","comments":true,"path":"2017/09/20/hexo入门指南（三）———分类和标签页/","link":"","permalink":"/2017/09/20/hexo入门指南（三）———分类和标签页/","excerpt":"hexo的分页和分类功能是没有被初始化的，需要特殊的设置才能使用这两个页面。","text":"hexo的分页和分类功能是没有被初始化的，需要特殊的设置才能使用这两个页面。 win10 + nodejs8.5.0 + git2.14.1 + indigo主题 设置标签页tags 在git bash中输入 1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 设置分类页categories 仅 card theme 支持。 1hexo new page categories 修改 hexo/source/tags/index.md 的元数据 123layout: categoriescomments: false--- 设置了标签页和分类页后，hexo会基于你的文章信息进行分类并添加到页面上。基本上不用理会这两个页面。 参考资料","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（二）——配置hexo","slug":"hexo入门指南（二）——配置hexo","date":"2017-09-20T12:25:24.000Z","updated":"2017-09-21T10:40:53.419Z","comments":true,"path":"2017/09/20/hexo入门指南（二）——配置hexo/","link":"","permalink":"/2017/09/20/hexo入门指南（二）——配置hexo/","excerpt":"按照上一篇文章，通过github pages可以访问你的博客。如果要做更个性化的设定，首先要修改hexo的项目配置文件_config.yml","text":"按照上一篇文章，通过github pages可以访问你的博客。如果要做更个性化的设定，首先要修改hexo的项目配置文件_config.yml 配置文件的详细信息。文件内容可能有差异，但是基本的东西还是不变的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Site #站点信息title: blog Name #标题subtitle: Subtitle #副标题description: my blog desc #描述author: me #作者language: zh-CN #语言timezone: Asia/Shanghai #时区# URLurl: http://yoururl.com #用于绑定域名, 其他的不需要配置root: /#permalink: :year/:month/:day/:title/permalink: posts/title.htmlpermalink_defaults:# Directory #目录source_dir: source #源文件public_dir: public #生成的网页文件tag_dir: tags #标签archive_dir: archives #归档category_dir: categories #分类code_dir: downloads/codei18n_dir: :lang #国际化skip_render:# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认模板(post page photo draft)titlecase: false #标题转换成大写external_link: true #新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true line_number: true #显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format #日期时间格式## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页per_page: 10 #每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions #插件和主题## 插件: http://hexo.io/plugins/## 主题: http://hexo.io/themes/theme: next# Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面deploy:- type: git repo: git@gitcafe.com:username/username.git,gitcafe-pages- type: git repo: git@github.com:username/username.github.io.git,master# Disqus #Disqus评论系统disqus_shortname:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap 参考资料","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（一）——安装","slug":"hexo入门指南（一）——安装","date":"2017-09-20T10:47:44.000Z","updated":"2017-10-20T14:58:24.404Z","comments":true,"path":"2017/09/20/hexo入门指南（一）——安装/","link":"","permalink":"/2017/09/20/hexo入门指南（一）——安装/","excerpt":"hexo是一个非常优秀的博客建设项目，github + node.js即可打造主题多样的博客界面。本站正是利用hexo建设的博客，稍微复习一下流程。","text":"hexo是一个非常优秀的博客建设项目，github + node.js即可打造主题多样的博客界面。本站正是利用hexo建设的博客，稍微复习一下流程。 为什么要做自己的博客呢？可能是为了装B吧，利用hexo建设的博客可以不用花钱，只可能花掉你部分学习时间。不过我更想有一个集中自己笔记的地方，原来喜欢在简书上面打MD，后来发现还是没自己博客的B装得好，所以就搞了这个博客。 概述hexo搭建博客可以分为以下几个步骤： 安装node.js和git github帐号申请和配置 安装hexo 配置hexo 将hexo和github关联起来 hexo常用操作 第一步：安装node.js和git安装git 先从官网下载git安装包，然后一路默认安装 建议直接安装最新版本（包括node.js），避免某些主题由于git和node.js版本问题而无法使用（此处是坑） 注意选择第二个 安装完成后在cmd中输入git --version检测安装结果 安装node.js 提供地址点击此处 下载对应版本 下载系统的对应版本，然后一路默认安装即可。 安装完成后在cmd中输入node -v和npm -v检测安装结果 第二步：github帐号申请和配置 github是世界上最大的同性交友平台，emm，好吧，它是一个流行的代码托管平台。利用github pages功能，让页面在网络上跑起来。 提供github官网。国内上github官网一般加载很久，解决方法请看此处 申请github帐号 点击New repository 输入Repository name为yourname.github.io 然后点击Create repository 现在应该可以在网址栏输入yourname.github.io查看你的github page（然而什么都没有）。 第三步：安装hexo 在磁盘合适的地方建一个文件夹，本文的路径是E:/blog 在文件夹内右键，点击git bash 在国内利用npm命令容易被墙，利用淘宝镜像可以轻松解决,之后的安装都用cnpm代替npm。$ npm install -g cnpm --registry=https://registry.npm.taobao.org 利用npm命令安装hexocnpm install -g hexo-clicnpm install hexo --save验证是否安装正确hexo -v 本地运行hexohexo init 这时候会有报错,这时候只要按照报错提示操作即可 如图执行cnpm install hexo安装完成。可在git bash输入hexo -v验证是否安装正确。 第四步：配置hexo安装主题 利用git命令克隆主题文件（以主题next为例）git clone https://github.com/iissnan/hexo-theme-next themes/next这里themes/next是安装路径，http..next是github地址。 更多主题浏览这里 修改配置文件 打开根目录下的_config.yml 修改基本配置 修改主题将theme栏的值改为next即可 测试你的网站在git bash中输入hexo g &amp;&amp; hexo s。打开浏览器，在地址栏输入localhost:4000，查看你的页面。正常情况下，你的页面已经在本地跑起来了。 第五步：将hexo和github关联起来 再次打开根目录下的_config.yml，修改配置。 安装hexo-deployer-git自动部署发布工具cnpm install hexo-deployer-git --save 发布到github上hexo clean &amp;&amp; hexo g &amp;&amp; hexo d第一次发布要求输入你的github帐号密码，可能会比较慢。 访问测试。发布完毕后在浏览器中输入https://yourname.github.io/ 第六步：hexo常用操作12345hexo new page \"page\" #新建页面hexo new \"article\" #新建文章hexo g #生成hexo s #启动服务预览hexo d #部署 更多hexo操作请看这里 参考资料 参考资料1","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]}]}